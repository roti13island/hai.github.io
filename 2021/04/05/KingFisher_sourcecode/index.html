<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> KingFisher 源码浅析 · Hays‘</title><meta name="description" content="KingFisher 源码浅析 - Hays Ren"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hays‘"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/5343481486" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/roti13island" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">KingFisher 源码浅析</h1><div class="post-info">Apr 5, 2021</div><div class="post-content"><p><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a>是一个纯 Swift 编写的图片加载库，支持图片的下载、缓存、处理（如分辨率、圆角、缩放）及设置时动画、占位图等等。充分利用了语言的特性实现丰富易用的 API ，良好的实践了 POP 的编程范式，且支持了最新的 SwiftUI。</p>
<h2 id="从一行调用开始"><a href="#从一行调用开始" class="headerlink" title="从一行调用开始"></a>从一行调用开始</h2><p>Kingfisher 的使用非常便捷：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://example.com/image.png"</span>)</span><br><span class="line">imageView.kf.setImage(with: url)</span><br></pre></td></tr></table></figure></p>
<p>当然也能处理更复杂的需求：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processor = <span class="type">DownsamplingImageProcessor</span>(size: imageView.bounds.size)</span><br><span class="line">             |&gt; <span class="type">RoundCornerImageProcessor</span>(cornerRadius: <span class="number">20</span>)</span><br><span class="line">imageView.kf.indicatorType = .activity</span><br><span class="line">imageView.kf.setImage(</span><br><span class="line">    with: url,</span><br><span class="line">    placeholder: <span class="type">UIImage</span>(named: <span class="string">"placeholderImage"</span>),</span><br><span class="line">    options: [</span><br><span class="line">        .processor(processor),</span><br><span class="line">        .scaleFactor(<span class="type">UIScreen</span>.main.scale),</span><br><span class="line">        .transition(.fade(<span class="number">1</span>)),</span><br><span class="line">        .cacheOriginalImage</span><br><span class="line">    ])</span><br><span class="line">&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Task done for: \(value.source.url?.absoluteString ?? "</span><span class="string">")"</span>)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Job failed: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同时也支持链式调用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KF</span>.url(url)</span><br><span class="line">  .placeholder(placeholderImage)</span><br><span class="line">  .setProcessor(processor)</span><br><span class="line">  .loadDiskFileSynchronously()</span><br><span class="line">  .cacheMemoryOnly()</span><br><span class="line">  .fade(duration: <span class="number">0.25</span>)</span><br><span class="line">  .lowDataModeSource(.network(lowResolutionURL))</span><br><span class="line">  .onProgress &#123; receivedSize, totalSize <span class="keyword">in</span>  &#125;</span><br><span class="line">  .onSuccess &#123; result <span class="keyword">in</span>  &#125;</span><br><span class="line">  .onFailure &#123; error <span class="keyword">in</span> &#125;</span><br><span class="line">  .<span class="keyword">set</span>(to: imageView)</span><br></pre></td></tr></table></figure></p>
<p>Kingfisher 的 API 涉及兼顾了易用与实用性，并且有着非常详尽的注释。下面就从最常用的 <code>imageView.kf.setImage()</code> 方法来看看 KingFisher 的具体实现（以下简称 <strong>KF</strong>, 与构造器 <code>KF</code> 注意区分）。</p>
<h3 id="kf-setImage"><a href="#kf-setImage" class="headerlink" title=".kf.setImage()"></a>.kf.setImage()</h3><p>以 <code>ImageView</code> 为例，<strong>KF</strong> 通过协议 <code>KingfisherCompatible</code> 封装了一个名为 kf 的变量并在其<code>get</code>方法中通过向泛型传入<code>self</code>来方便对不同类型的拓展。忽略夸平台的代码后简化如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageView 实例变量 kf 的封装</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">KingfisherCompatible</span>: <span class="title">AnyObject</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KingfisherCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kf: <span class="type">KingfisherWrapper</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">KingfisherWrapper</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageView</span>: <span class="title">KingfisherCompatible</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意计算属性<code>kf</code>是一个<code>KingfisherWrapper</code>类型的结构体，这个结构体是对原生对象的封装，目的是为原生类拓展相应的自定义方法，通过泛型可以锁定原生类型，并通过 <code>base</code>实例对象持有该原生对象以供后续使用，取自 ImageView+KingFisher.swift 文件(忽略跨平台别名)：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KingfisherWrapper</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">ImageView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(）&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>以上便是 <strong>KF</strong> 利用协议和泛型对 ImageView 进行封装与能力的拓展，至此即可调用<code>imageView.kf.setImage()</code>了。</p>
<p>下面就通过<code>setImage()</code>方法的参数来分析下 <strong>KF</strong> 的一些功能封装与思想</p>
<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(with source: Source?)</span></span></span><br></pre></td></tr></table></figure>
<p><code>Source</code>是一个用来表示图片“来源”的枚举，一共两个 case ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 图片来自网络或本地（取决于 url 格式）</span></span><br><span class="line">	<span class="keyword">case</span> network(<span class="type">Resource</span>)</span><br><span class="line">	<span class="comment">// 图片来自本地或其它编码格式</span></span><br><span class="line">	<span class="keyword">case</span> provider(<span class="type">ImageDataProvider</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>先看<code>.network</code>，它的关联值是遵守<code>Resource</code>协议的对象，该协议的目的较简单，作用是通过<code>convertToSource</code>方法将一些通用资源转为 <code>Source</code>以方便进行 cache 和 download 。当然最常用的资源就是 url ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span>: <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">return</span> absoluteString &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然你也可以通过遵守<code>Resource</code>协议定义自己的资源类，只要提供缓存 key 和下载 url 即可交给 <strong>KF</strong> 处理。</p>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p><code>Source</code>的另一个 case 是 provider ，它的关联值类型是<code>ImageDataProvider</code>。主要封装了本地图片的资源，该协议除了 cacheKey 和 fileURL 外，还要求提供一个处理图片 data 的方法供后续处理使用。<code>ImageDataProvider</code>同 <code>Resource</code>一样，提供了将资源转为<code>Source</code>的默认实现。</p>
<p>此外，<strong>KF</strong> 还提供了四个默认的 Provider ，分别为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于本地文件路径下的图片资源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocalFileImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于 Base64 编码的图片，需提供 Base64 字符串</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base64ImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于图片 data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RawImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于处理 AVAsset 资源截图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVAssetImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>Source</code>可以看到协议的优势，具有高拓展性、更好的抽象能力，另外也可以看到 Swift 中 Enum 的强大。</p>
<h2 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h2><p>Placeholder 的作用是在图片加载时或图片加载失败的情况下显示的默认图，<strong>KF</strong>通过协议<code>Placeholder</code>声明了两个方法并针对<code>UIView</code>和<code>UIImage</code>做了默认实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Placeholder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Placeholder</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span> &#123;</span><br><span class="line">        imageView.addSubview(<span class="keyword">self</span>)</span><br><span class="line">        translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        heightAnchor.constraint(equalTo: imageView.heightAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        widthAnchor.constraint(equalTo: imageView.widthAnchor).isActive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span> &#123;</span><br><span class="line">        removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这个 extension 自定义的 View 也可以作为默认图被添加到 ImageView 上。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span>: <span class="title">Placeholder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span> &#123; imageView.image = <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span> &#123; imageView.image = <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若默认图为<code>UIImage</code>则会被直接设置。</p>
<p>之后通过<code>KingfisherWrapper</code>封装的计算属性<code>placeholder</code>的<code>set/get</code>方法来调用其<code>add()</code>方法，并通过<code>setRetainedAssociatedObject()</code>来为 imageView 动态绑定属性。</p>
<blockquote>
<p><strong>Associated Objects</strong> 是 ObjC Runtime 提供的运行时绑定属性的能力，内部通过两层 Hash Map 来维护所有对象动态绑定的变量，但需注意同名覆盖问题  </p>
</blockquote>
<h2 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h2><p>Indicator 的作用是提示图片正在下载，同样是在<code>setImage()</code>方法内进行设置，通过<code>IndicatorType</code>提供了四种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum IndicatorType &#123;</span><br><span class="line">    case none</span><br><span class="line">    case activity</span><br><span class="line">    case image(imageData: Data)</span><br><span class="line">    case custom(indicator: Indicator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但比较不解的是设置的方式，<strong>KF</strong> 并未在<code>setImage()</code>系列方法中提供相应参数，因此使用时需提前设置<code>imageView.kf.indicatorType = .activity</code>。</p>
<p>Indicator 的行为通过<code>Indicator</code>协议来抽象，并提供两种默认的实现，<code>ActivityIndicator</code>封装了系统的 progress view 和菊花两种样式，<code>ImageIndicator</code>封装的是图片样式，支持 Gif 格式。</p>
<h2 id="KingfisherOptionsInfo"><a href="#KingfisherOptionsInfo" class="headerlink" title="KingfisherOptionsInfo"></a>KingfisherOptionsInfo</h2><p><code>setImage()</code>之后的工作便是整合<code>options</code>这个参数，这个参数的类型是<code>[KingfisherOptionsInfoItem]</code>，<code>KingfisherOptionsInfoItem</code>是一个枚举，提供了丰富的配置项，涉及缓存、下载、图片处理、动画以及一些行为开关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">enum KingfisherOptionsInfoItem &#123;</span><br><span class="line">    case targetCache(ImageCache)</span><br><span class="line">    case originalCache(ImageCache)</span><br><span class="line">    case downloader(ImageDownloader)</span><br><span class="line">    case transition(ImageTransition)</span><br><span class="line">    case downloadPriority(Float)</span><br><span class="line">    case forceRefresh</span><br><span class="line">    case fromMemoryCacheOrRefresh</span><br><span class="line">    case forceTransition</span><br><span class="line">    case cacheMemoryOnly</span><br><span class="line">    case waitForCache</span><br><span class="line">    case onlyFromCache</span><br><span class="line">    case backgroundDecode</span><br><span class="line">    case callbackQueue(CallbackQueue)</span><br><span class="line">    case scaleFactor(CGFloat)</span><br><span class="line">    case preloadAllAnimationData</span><br><span class="line">    case requestModifier(AsyncImageDownloadRequestModifier)</span><br><span class="line">    case redirectHandler(ImageDownloadRedirectHandler)</span><br><span class="line">    case processor(ImageProcessor)</span><br><span class="line">    case cacheSerializer(CacheSerializer)</span><br><span class="line">    case imageModifier(ImageModifier)</span><br><span class="line">    case keepCurrentImageWhileLoading</span><br><span class="line">    case onlyLoadFirstFrame</span><br><span class="line">    case cacheOriginalImage</span><br><span class="line">    case onFailureImage(KFCrossPlatformImage?)</span><br><span class="line">    case alsoPrefetchToMemory</span><br><span class="line">    case loadDiskFileSynchronously</span><br><span class="line">    case memoryCacheExpiration(StorageExpiration)</span><br><span class="line">    case memoryCacheAccessExtendingExpiration(ExpirationExtending)</span><br><span class="line">    case diskCacheExpiration(StorageExpiration)</span><br><span class="line">    case diskCacheAccessExtendingExpiration(ExpirationExtending)</span><br><span class="line">    case processingQueue(CallbackQueue)</span><br><span class="line">    case progressiveJPEG(ImageProgressive)</span><br><span class="line">    case alternativeSources([Source])</span><br><span class="line">    case retryStrategy(RetryStrategy)</span><br><span class="line">    case lowDataMode(Source?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之后<strong>KF</strong>将<code>options</code>连同<code>source</code>、<code>completion</code>等作为参数传至<br><code>KingfisherManager.shared.retrieveImage()</code>方法并返回一个 task 。至此我们通过<code>setImage()</code>方法见到了 <strong>KF</strong> 核心功能的调度者<code>KingfisherManager</code>，它的工作包括下载、存取（缓存）、处理。下面通过<code>KingfisherManager</code>来具体看下这些核心功能的实现。</p>
<hr>
<h2 id="KingfisherManager"><a href="#KingfisherManager" class="headerlink" title="KingfisherManager"></a>KingfisherManager</h2><p>这个类的核心是名为<code>retrieveImage()</code>的系列方法，除了供外部调用的两个方法，还包括内部对参数的处理，以及对重试、成功及失败的各种 handle ，这里不具体展开了，着重看下最终的调用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">retrieveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        with source: Source,</span></span></span><br><span class="line"><span class="function"><span class="params">        context: RetrievingContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: <span class="params">(<span class="params">(Result&lt;RetrieveImageResult, KingfisherError&gt;)</span></span></span></span> -&gt; <span class="type">Void</span>)?) -&gt; <span class="type">DownloadTask?</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> options = context.options</span><br><span class="line">        <span class="keyword">if</span> options.forceRefresh &#123;</span><br><span class="line">            <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)?.value</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> loadedFromCache = retrieveImageFromCache(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> loadedFromCache &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> options.onlyFromCache &#123;</span><br><span class="line">                <span class="keyword">let</span> error = <span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: source.cacheKey))</span><br><span class="line">                completionHandler?(.failure(error))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)?.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的调用的两个方法<code>loadAndCacheImage()</code>和<code>retrieveImageFromCache()</code>分别负责加载并缓存图片以及从缓存中读取。通过之前传入的<code>options</code>来判断。</p>
<h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p><strong>KF</strong> 通过<code>ImageDownloader</code>类用来管理图片的下载，提供相应的接口，下载任务是由封装了<code>URLSessionDataTask</code>的<code>SessionDataTask</code>实现，并对并发任务做了优化。另外需要注意的是<code>SessionDelegate</code>这个类，除了作为<code>URLSessionDataDelegate</code>的 handler ，也承担了下载任务的维护。</p>
<p><code>ImageDownloader</code> 是对外暴露的图片下载管理类，提供图片下载和取消的接口。接受<code>SessionDelegate</code>的回调，并通过<code>ImageDownloaderDelegate</code>来供外部处理下载结果及在处理下载周期中各时间点的时机。</p>
<p>此外在 downloadImage 方法的<code>option</code>参数中提供了一个<code>requestModifier</code>，在 request 发出之前支持对其进行修改，如添加 header 、map URL 等，体现了良好的开放性。</p>
<p>前面提到<code>SessionDataTask</code>是对<code>URLSessionDataTask</code>的封装，其内部声明了一个结构体<code>TaskCallback</code>，保存 downloadImage 方法中传入的回调以及 options ，用于后续下载流程使用。其中比较重要的是在图片下载完成后，通过<code>ImageDataProcessor</code>来将下载下来的 data 处理为图片，处理时会从<code>TaskCallback</code>对象中的 option 取出 <code>ImageProcessor</code>对象并调用其<code>process</code>方法，处理完成后通过 callback 返回结果。如果你不想对图片进行额外处理，<strong>KF</strong> 默认提供了<code>DefaultImageProcessor</code>。</p>
<p>从这个简单的 downloadImage 系列方法可以看到 SDK 设计的重要原则，为调用者提供充分的拓展性，同时在内部约束这些开放的行为，良好的实践了开闭原则。其它的一些细节包括封装了一个<code>Delegate</code>类来帮助管理 closure 中对<code>self</code>的弱引用（感觉作用不大），一个名为<code>CallbackQueue</code>的枚举来方便任务派发的线程等。</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><strong>KF</strong> 提供的缓存同时支持内存缓存与磁盘缓存，可分别设置缓存过期时间及占用大小，同时维护了 IO 线程以保证读写安全。在 init 方法中分别初始化内存与磁盘缓存类，内存缓存的默认大小是设备物理内存大小的 1/4 ，接着初始化线程，注册通知：收到<code>didReceiveMemoryWarningNotification</code>时去清理内存缓存，收到<code>willTerminateNotification</code>和<code>didEnterBackgroundNotification</code>时清理磁盘空间。</p>
<p>存储图片时会首先将图片存入内存缓存，如果<code>toDisk</code>参数为 true ，则在 IO 线程中将图片写入磁盘，删除图片时也会同时检查内存缓存与磁盘缓存。</p>
<p>从缓存中取图片的流程是首先检查内存缓存，查到后直接返回，否则去查磁盘缓存，若查到则先将图片写入内存，写入完成后再将图片通过回调返回。<strong>KF</strong>也提供了直接从内存或磁盘取图片的接口。</p>
<p>清空缓存没有什么特别，同样提供的统一清理和分别清理内存和磁盘缓存的接口，已经后台清理磁盘缓存的功能。</p>
<p>此外还包括查询图片是否已被缓存、缓存的类型、缓存的 key 对应的文件名，以及查询已用的磁盘缓存空间等。下面来看下内存缓存与磁盘缓存的具体实现。</p>
<h4 id="Memory-cache"><a href="#Memory-cache" class="headerlink" title="Memory cache"></a>Memory cache</h4><p>首先不太理解的是<strong>KF</strong>的<code>MemoryStorage</code>本身是个遵守<code>Storage</code>协议的类。但后面被改为了 enum ，仅作用为一个命名空间，内部封装的<code>Backend</code>才是真正实现缓存逻辑的类。此外还封装了<code>Congfig</code>以及<code>StorageObject</code>。</p>
<p><code>Backend</code>是一个泛型类，即只保存该泛型的数据，同时<code>CacheCostCalculable</code>要求提供一个<code>cacheCost</code>变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Backend</span>&lt;<span class="title">T</span>: <span class="title">CacheCostCalculable</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KFCrossPlatformImage</span>: <span class="title">CacheCostCalculable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Cost of an image</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheCost: <span class="type">Int</span> &#123; <span class="keyword">return</span> kf.cost &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其内部持有了一个<code>NSCache</code>对象，key 为<code>String</code>，value 为<code>StorageObject</code>。所以<strong>KF</strong>的内存缓存就是通过<code>NSCache</code>实现的，虽然<code>NSCache</code>是号称线程安全，但<strong>KF</strong>还是给读写操作加了锁。</p>
<p>此外在内存的清理上，<strong>KF</strong>起了一个 timer 来定时清理过期的缓存对象，默认间隔为 2 分钟，过期时间默认为 5 分钟。而且提到的<code>ImageCache</code>类在接受到<code>didReceiveMemoryWarningNotification</code>时会直接将内存缓存清空。</p>
<h4 id="Disk-cache"><a href="#Disk-cache" class="headerlink" title="Disk cache"></a>Disk cache</h4><p>磁盘缓存是通过<code>FileManager</code>进行数据读写的，但<strong>KF</strong>额外的做了几件事。</p>
<p>同<code>MemoryStorage</code>一样，<code>DiskStorage</code>也是一个没有 case 的枚举，内部同样声明了一个泛型类<code>Backend</code>来实现缓存的主要逻辑，但泛型约束协议与<code>MemoryStorage</code>不同：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataTransformable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toData</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromData</span><span class="params">(<span class="number">_</span> data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> empty: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该协议要求实现 Data 与 Self 的相互转换，并提供一个空数据的实现。主要用于从 File system 存取数据时的类型转换。</p>
<p>为了提高查找效率，<strong>KF</strong>维护了一个<code>Set</code>用来保存已存入缓存的文件名，在查找文件时优先检查该 set 中是否有对应文件名，如果没有直接返回 nil 已减少对 File system 的访问次数。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一行调用开始，分析了<strong>KF</strong>提供的各种特性及实现，并重点关注了下载和缓存的实现，当然还有很多细节没有覆盖到，比如图片的绘制（圆角、裁切、效果）、图片格式的处理等等。</p>
<p><strong>KF</strong>充分的利用了 Swift 语言的特性，在 API 的设计上非常实用且规范，同时保留了足够的可拓展性，在具体实现层面，<strong>KF</strong>并没有采用特别复杂的技术方案，但功能完善且实用性强，是一个值得学习的开源项目。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/06/02/Associated_Objects/" class="prev">上一篇</a><a href="/2021/03/01/ios_launch_optimize/" class="next">下一篇</a></div><div class="copyright"><p>© 2019 - 2021 <a href="http://yoursite.com">Hays Ren</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>