<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS 启动速度优化 · Hays‘</title><meta name="description" content="iOS 启动速度优化 - Hays Ren"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hays‘"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/5343481486" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/roti13island" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS 启动速度优化</h1><div class="post-info">Mar 1, 2021</div><div class="post-content"><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>在做优化前应将应用当前的耗时情况进行完善的统计，以便后续通过数据发现问题，以及对比优化效果。<br>我们的统计工作分位两个维度，一个是启动耗时的分段耗时及总耗时的统计，另一个是针对具体的启动项或函数的耗时进行统计及上报。</p>
<h3 id="启动耗时统计"><a href="#启动耗时统计" class="headerlink" title="启动耗时统计"></a>启动耗时统计</h3><p>我们将启动耗时分成两个阶段，第一阶段从系统创建 APP 进程（用户点击图标）到 <code>main</code> 函数开始执行，即 <strong>pre-main</strong> 阶段。第二阶段即从  <code>didFinishLaunching</code> 开始执行到首页渲染完毕。<br>至于 <code>main</code> 函数到 <code>didFinishLaunching</code> 开始这段耗时根据我们的统计占用耗时较少（约为几十毫秒）且浮动不大，因此将第二阶段的起点放在 <code>didFinishLaunching</code> 的开始，但在统计总体耗时的时候还是会将其包括在内。</p>
<h4 id="Pre-main-耗时统计"><a href="#Pre-main-耗时统计" class="headerlink" title="Pre-main 耗时统计"></a>Pre-main 耗时统计</h4><p>在调试时可以通过增加 <code>DYLD_PRINT_STATISTICS</code> 和 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 来打印出 <strong>dyld</strong> 的启动耗时，包括了各阶段的耗时及链接的动态库列表，但该耗时不包括加载 <strong>dyld</strong> 及之前的耗时。可以作为优化时的参考。<br>对于数据的上报，我们通过在 <code>main</code> 函数执行时通过 <code>sysctl</code> 函数去拿到进程创建的时间，具体如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)processInfoForPID:(<span class="keyword">int</span>)pid procInfo:(<span class="keyword">struct</span> kinfo_proc*)procInfo &#123;</span><br><span class="line">    <span class="keyword">int</span> cmd[<span class="number">4</span>] = &#123;<span class="built_in">CTL_KERN</span>, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size = <span class="keyword">sizeof</span>(*procInfo);</span><br><span class="line">    <span class="keyword">return</span> sysctl(cmd, <span class="keyword">sizeof</span>(cmd)/<span class="keyword">sizeof</span>(*cmd), procInfo, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimeInterval</span>)processStartTime &#123;</span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc kProcInfo;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> processInfoForPID:[[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        <span class="keyword">return</span> kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * <span class="number">1000.0</span> + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后以 <code>main</code> 函数开始执行作为 <strong>Pre-main</strong> 阶段的终点进行数据上报。</p>
<h4 id="After-main-耗时统计"><a href="#After-main-耗时统计" class="headerlink" title="After-main 耗时统计"></a>After-main 耗时统计</h4><p>以 <code>didFinishLaunching</code> 开始执行为起点，到首页渲染完成为终点。这里的终点会有几种打点方式，之前我们以首页的 <code>viewDidAppear</code> 首次调用作为首页渲染完成的标志，并在优化过程中将非必要启动项置于该方法的回调之后。但经过几个版本的数据分析（项目接入的 APM 监控）发现这块耗时会有较多的极端数据出现，且难以排查到具体原因和复现，因此我们决定修改该阶段终点的打点时机。<br>Apple 的 APM 统计 <strong>Metrics</strong> 框架将启动耗时的终点定在第一次 <code>CA::Transaction::commit</code>。而抖音的方案是根据 iOS 的版本，iOS 12 及以下使用 <code>viewDidAppear</code>，否则以 <code>applicationDidBecomeActive</code> 作为终点。<br>最终我们决定使用 <strong>Metrics</strong> 的做法，去监听 first <code>CA::Transaction::commit</code>，方式是通过 <strong>Runloop</strong> 来监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop]getCFRunLoop];</span><br><span class="line">if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">    CFRunLoopActivity activities = kCFRunLoopAllActivities;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, activities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        if (activity == kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            // 打点记录</span><br><span class="line">            CFRunLoopRemoveObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    CFRunLoopPerformBlock(mainRunloop, NSDefaultRunLoopMode, ^&#123;</span><br><span class="line">        // 打点记录</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统对于界面更新的处理方式是当 <code>UIView/CALayer</code> 发生属性变动、层级变动或设置了 <code>setNeedsLayout/setNeedsDisplay</code> 时，该 <code>UIView/CALayer</code> 会被标记为待处理并被提交到一个全局容器中。然后在通过 Runloop 中监听 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 两个事件，来处理被标记的视图变化，具体是调用了 <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 这个方法，其内部调用栈大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure></p>
<p>具体可参考 YY 关于 Runloop 的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">这篇文章</a>。<br>因此通过监听 Runloop 的事件可以拿到与第一次 <code>CA::Transaction::commit()</code> 非常接近的时间点。但经过实际测试发现，不同系统的回调时机会有较大的差异，不能简单的监听 Runloop 的第一次 <code>beforeWaiting</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// iOS 13.1.3</span><br><span class="line">kCFRunLoopBeforeTimers: 1088171.925382</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.049286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.062607</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.081497</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.094928</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.095982</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096508</span><br><span class="line">kCFRunLoopBeforeWaiting: 1088172.096728</span><br><span class="line">First View Did Appear: 1088172.154152</span><br><span class="line"></span><br><span class="line">// iOS 14.3</span><br><span class="line">First View Did Appear: 13255.515243</span><br><span class="line">kCFRunLoopBeforeTimers: 13255.545548</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.364940</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.365692</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.380215</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381132</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381725</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381765</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381807</span><br><span class="line">kCFRunLoopBeforeWaiting: 13257.381919</span><br></pre></td></tr></table></figure></p>
<p>可以看到在 iOS 13 上的表现基本符合预期，在提交了 Transaction 后的某个时间点首页渲染完成并调起了 <code>viewDidAppear</code> ，但在 iOS 14 上，Runloop 的回调会晚于 <code>viewDidAppear</code> 。<br>因此在该阶段终点即整个启动阶段的终点的打点时机上，如果想要监听 first <code>CA::Transaction::commit()</code>，需要对系统进行区分以获取最合理的时机，或者采用 first <code>viewDidAppear</code>加 first <code>applicationDidBecomeActive</code>的方式也是可以的。</p>
<h2 id="分阶段优化"><a href="#分阶段优化" class="headerlink" title="分阶段优化"></a>分阶段优化</h2><h3 id="Pre-main-阶段"><a href="#Pre-main-阶段" class="headerlink" title="Pre-main 阶段"></a>Pre-main 阶段</h3><p>通过 <code>DYLD_PRINT_STATISTICS</code> 可以比较清楚的看到该阶段内做了哪些事情以及它们的耗时情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 948.13 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 145.53 milliseconds (15.3%)</span><br><span class="line">        rebase/binding time: 113.82 milliseconds (12.0%)</span><br><span class="line">            ObjC setup time: 165.37 milliseconds (17.4%)</span><br><span class="line">           initializer time: 523.40 milliseconds (55.2%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :   5.35 milliseconds (0.5%)</span><br><span class="line">    libMainThreadChecker.dylib :  25.31 milliseconds (2.6%)</span><br><span class="line">          libglInterpose.dylib : 213.90 milliseconds (22.5%)</span><br><span class="line">              MyApp : 465.52 milliseconds (49.0%)</span><br></pre></td></tr></table></figure></p>
<p>其实在 dylib loading 开始前，系统会创建进程并为其开辟内存空间，然后加载可执行文件。之后加载 dyld（本身也是动态库），创建启动闭包（dyld3 ，更新 App 或重启手机后），完成后 dyld 开始分析动态库依赖，并逐一加载，即 <code>dylib loading time</code> 开始。加载完成后需对动态库进行符号绑定，即 <code>rebase/binding time</code>。因此动态库的数量是影响这段耗时的主要因素，包括系统库，而我们的项目已经全部采用静态库的方式。不但减少启动耗时，也可减少包体积。</p>
<p>之后的 <code>ObjC setup time</code> 的主要工作是 <code>Class</code> 注册、<code>Category</code> 注册（向类中插入方法）及方法唯一性检查等。这一段的优化工作主要在无用类及 <code>Category</code> 的检查上，之前常规的方案是通过 Mach-O 文件分析，取 <code>classlist</code> 与 <code>classref</code> 的差集，但这里推荐一个准确性更高的工具：<a href="https://github.com/wuba/WBBlades" target="_blank" rel="noopener">WBBlades</a>，通过分析 Mach-O 文件，解决了类的动态调用、类的继承关系和类内调用等问题。</p>
<p><code>initializer time</code> 中主要是 <code>+load()</code> 方法调用、<strong>c++</strong> 构造函数和静态全局变量的创建。而 <code>+load()</code> 方法除了本身的耗时，还会触发 Page in 读入物理内存以执行该函数。从上面的 log 可以看到这段耗时占到整个 Pre-main 耗时的一半以上，因此针对 <code>+load()</code> 方法的优化就是尽可能不用该方法，改为 <code>+initialize()</code>等懒加载的方式。对于 <strong>c++</strong> 的静态初始化，可将 <code>static</code> 变量迁移至方法内部以改为懒加载的方式，借鉴<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487757&amp;idx=1&amp;sn=a52c11f6a6f217bd0d3283de9b00c8bc&amp;chksm=e9d0daefdea753f954cfcb15d5d0f90302a9f45ba06968377644ffe9e5757a69c5b0132d2c8b&amp;mpshare=1&amp;scene=1&amp;srcid=0125oJOAovQbQckW9TdR8cTn&amp;sharer_sharetime=1611540323121&amp;sharer_shareid=4e61187060391b97449b816517d4ddd7&amp;version=3.0.31.6162&amp;platform=mac#rd" target="_blank" rel="noopener">这篇</a>的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="After-main-阶段"><a href="#After-main-阶段" class="headerlink" title="After-main 阶段"></a>After-main 阶段</h3><p>该阶段的优化重点是启动项、首页的初始化及生命周期方法。</p>
<h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><p>启动项的治理思路比较简单，将非必要的启动项通过置后、异步或懒加载等方式来减少耗时。<br>另外，可以针对启动项进行统一管理，如耗时统计，包括线下 log 及线上监控，在我们的优化过程中发现仅以本地 log 作为依据是无法完全覆盖所有的启动场景的，在上线了线上监控后发现某些启动项耗时会有很大的波动，出现较高的耗时。在了解启动项耗时的基本情况后，再对高耗时的启动项进行摸排，找到具体耗时原因进行优化。<br>启动项统一管理的作用还包括解决启动依赖、控制并发、更好的管控新增的启动项等。</p>
<h4 id="首页耗时"><a href="#首页耗时" class="headerlink" title="首页耗时"></a>首页耗时</h4><p>这一阶段的主要工作包括首页及相关页面对子视图的加载渲染、网络请求、数据同步、各配置项的同步及组件的初始化等等。对于这段耗时的监控我们借助了 Instrument 的 Time Profiler 以及本地打点的方式。其中 Time Profiler 使用的时定期抓取主线程堆栈的方式，间隔为 1ms ，通过对线程快照的对比来进行耗时统计。如果觉得 Time Profiler 粒度太粗也可以自行设置间隔来抓取主线程的堆栈，如通过 <code>Thread.callStackSymbols</code> 或 <code>__builtin_frame_address</code>取到当前栈帧的地址，通过 <code>dladdr(UnsafeRawPointer(bitPattern: address), &amp;i)</code> 得到该栈帧的 <code>dl_info</code>，该结构体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public struct dl_info &#123;</span><br><span class="line">		public var dli_fname: UnsafePointer&lt;Int8&gt;! //* Pathname of shared object *//</span><br><span class="line">		public var dli_fbase: UnsafeMutableRawPointer! //* Base address of shared object *//</span><br><span class="line">    public var dli_sname: UnsafePointer&lt;Int8&gt;! //* Name of nearest symbol *//</span><br><span class="line">    public var dli_saddr: UnsafeMutableRawPointer! //* Address of nearest symbol *//</span><br><span class="line">    public init()</span><br><span class="line">    public init(dli_fname: UnsafePointer&lt;Int8&gt;!, dli_fbase: UnsafeMutableRawPointer!, dli_sname: UnsafePointer&lt;Int8&gt;!, dli_saddr: UnsafeMutableRawPointer!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>dli_sname</code>即为符号名。最后通过 <code>Frame Pointer</code> 的偏移来遍历整个调用栈的符号。<br>另一种思路是直接对方法进行打点，比较容易想到的是 hook <code>objc_msgsend</code>，但弊端是静态函数记录不到，如纯 Swift 方法。也可在编译期通过对代码进行插桩实现打点，如利用 Clang 提供的代码覆盖工具 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs" target="_blank" rel="noopener">SanitizerCoverage</a>，可覆盖 OC/Swift/C/C++ 等语言。<br>具体的耗时情况及解决办法也是因项目而异的，比较通用的耗时点比如子视图的加载，在我们的项目中使用了 <code>MJRefreshGifHeader</code> , 并在其初始化时从 bundle 中分别取了 15 至 20 张图片传至 GifHeader 中不同的状态，造成了大量的耗时。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h3><blockquote>
<p>页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。<br>每触发 Page fault 都会有一定的耗时（一次约 0.6~0.8 ms），当触发量足够多时其耗时也是比较可观的。具体消耗可通过 <strong>Instruments</strong> 的 System Trace 查看，注意这个消耗不是恒定的，受系统内存使用情况的影响，因此在测试前可重启手机，或打开多个 App 来尽量占用系统内存。<br>Xcode 在 Build Settings - Linking - Order File 中提供了一个设置 Order file 的路径。该文件是一个<code>.order</code>后缀的文本文件，链接器会根据该文件改变其中符号在内存中的布局，且会置于对应 section 的开始，对于不存在的符号会选择忽略。<br>因此通过将启动过程中所使用的函数符号通过 order file 告知链接器进行重排，将它们尽量排在相邻靠前的内存页中，从而减少 Page fault 触发次数，进而减少启动耗时。<br>因此重排的终点就是生成覆盖面尽量全的 order file。<br>我们采用的方式是 Clang 提供的 SanitizerCoverage，也就是编译期插桩的方式。该方案的优势在于覆盖面广（OC/Swift/C++，method/function/block），侵入性小，开发成本少（有很多现成的方案可借鉴，实现都大同小异）。将启动到首页显示期间运行的函数符号记录在 order file 中，然后放入项目路径下，可通过 LinkMap 来对比使用前后的符号排列是否变化。<br>至于具体的优化效果，本地测试下来成效不是很明显。而且本身对二进制重排并没有抱多少期望，只是在做完基础优化工作后的额外尝试，效果有点算点吧~</p>
</blockquote>
<h3 id="TEXT-段重命名"><a href="#TEXT-段重命名" class="headerlink" title="__TEXT 段重命名"></a>__TEXT 段重命名</h3><p>因为 App Store Connect 会对我们上传 Mach-O 的 Text 段进行加密，以防止代码的泄露。而在启动过程会触发大量的 Page in 动作，其中包括将 Text 段的页读入物理内存，这就需要先对其解密，从而产生耗时以及 Text 段的体积变大。（此过程已在 iOS 13 被优化，Page in 不需要再解密了）<br>如果你的应用仍支持 iOS 13 以下的版本，比如我们还在 iOS 9 😓 。可以尝试一下段重命名的方案。链接器 ld 的 <code>-rename-section</code> 命令可以将 Text 段的内容移至其它的段，从而规避解密的耗时。具体可看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487459&amp;idx=1&amp;sn=3dd9276f5af78ca5a377adec37e3e916&amp;chksm=e9d0c401dea74d17e9f1bdd5ea764cc0cd7e845c6ebadde752d36608306b09e762a1681c7252&amp;scene=178&amp;cur_album_id=1665528287604817930#rd" target="_blank" rel="noopener">这篇</a>，跟重排一样，不用抱太大希望，不过对包大小的优化效果还是有的。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/07/05/ARTS_week_5/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2021 <a href="http://yoursite.com">Hays Ren</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>