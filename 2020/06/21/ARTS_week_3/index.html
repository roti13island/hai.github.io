<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARTS 第三周 · Hays‘</title><meta name="description" content="ARTS 第三周 - Hays Ren"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hays‘"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/5343481486" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/roti13island" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARTS 第三周</h1><div class="post-info">Jun 21, 2020</div><div class="post-content"><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 287: 寻找重复数</a></p>
<blockquote>
<p>给定一个包含<code>n + 1</code>个整数的数组<code>nums</code>，其数字都在 1 到 n之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>示例 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><strong>思路：</strong><br>该算法可用<strong>二分法</strong>、<strong>二进制</strong>或<strong>快慢指针</strong>等等方法来解，本次主要记录一下<strong>快慢指针</strong>的方法。<br><strong>快慢指针</strong>的方法主要借鉴了 <strong>Floyd 判圈算法</strong>，该算法主要用于检测链表是否有环。在本题中对<code>nums</code>建图，可将问题等价为： <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode142:  环形链表 II</a>  ，可分别设置快慢指针，慢指针每次走一步，快指针每次走两步，根据 <strong>Floyd 判圈算法</strong>两指针在有环的情况下一定会相遇，相遇后将慢指针放置起点，然后两个指针每次同时走一步，相遇点便是答案。</p>
<p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> slow = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow)</span><br><span class="line"></span><br><span class="line">    slow = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://allegro.tech/2014/12/swift-method-dispatching.html" target="_blank" rel="noopener">Swift Method Dispatching</a></p>
<p><strong>Swift</strong> 作为一门静态语言，其在方法派发上的性能表现要强于 <strong>OC</strong> 不少，本文中主要介绍了 <strong>Swift</strong> 的方法派发机制。</p>
<p>在 <strong>OC</strong> 中，<strong>clang</strong> 会将方法调用翻译成对<code>objc_msgSend</code>这个函数的调用，传入相应的<code>target</code>、<code>SEl</code>以及参数，该方法是由汇编实现的，负责<strong>OC</strong>中的方法派发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id obj, SEL op, … )</span><br><span class="line">&#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line">    IMP imp = CacheLookup(c, op);</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        imp = class_getMethodImplementation(c, op);</span><br><span class="line">    &#125;</span><br><span class="line">    jump imp(obj, op, …);]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，影响效率的最大因素在于找到具体的方法实现<code>IMP</code>，如果方法缓存命中，那么效率上基本等同于在<code>hashMap</code>中取值，这种情况还好，但如果未命中，则需要去沿着继承体系在类的方法列表中寻找对应的实现并加入缓存，再跳到该实现执行具体函数，这样的派发方式相对较慢。因此<code>objc_msgSend</code>也被称为跳板函数。</p>
<p>在 <strong>Swift</strong> 中，使用了 <strong>Virtual Method Table</strong> 来支持运行时的方法绑定，文章通过对 <strong>SIL</strong> 的分析发现 <strong>vtable</strong> 本质上是一个 key 为方法名，value 为方法实现的字典，而通过汇编代码可以看到 <strong>Swift</strong> 代码几乎做到了将调用方法直接映射到处理器指令，并将调用对象存入寄存器中。通过传入对象中指向 <code>metadata</code> 的指针找到保存其类信息的结构体，进而通过偏移量找到相应的方法。</p>
<p>当打开编译期优化选项后，<strong>Swift</strong> 代码执行速度可能更快，原因在于：</p>
<ul>
<li>当编译器知道目标对象的具体类型后，non-final 方法可被直接调用</li>
<li>编译期会用内联的方式直接将方法实现内联至方法调用的地方，从而省去了函数调用的开销</li>
</ul>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周依旧记录 <strong>Swift</strong> 的新特性，版本来到<code>5.3</code>。</p>
<h4 id="Multi-pattern-catch-clauses"><a href="#Multi-pattern-catch-clauses" class="headerlink" title="Multi-pattern catch clauses"></a>Multi-pattern catch clauses</h4><p>简单来说，一个<code>catch</code>代码块可以 handle 多种错误类型了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureError: Error &#123;</span><br><span class="line">    case tooCold, tooHot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let result = try checkReactorOperational()</span><br><span class="line">    print(“Result: \(result)”)</span><br><span class="line">&#125; catch TemperatureError.tooHot, TemperatureError.tooCold &#123;</span><br><span class="line">    print(“Shut down the reactor!”)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(“An unknown error occurred.”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Multiple-trailing-closures"><a href="#Multiple-trailing-closures" class="headerlink" title="Multiple trailing closures"></a>Multiple trailing closures</h4><p>多个尾随闭包也被支持了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Before</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="Synthesized-Comparable-conformance-for-enums"><a href="#Synthesized-Comparable-conformance-for-enums" class="headerlink" title="Synthesized Comparable conformance for enums"></a>Synthesized Comparable conformance for enums</h4><p>实现<code>Comparable</code>的枚举可以用来比大小了，如果带有的关联值也是<code>Comparable</code>的话，也是可以比的哦~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum WorldCupResult: Comparable &#123;</span><br><span class="line">    case neverWon</span><br><span class="line">    case winner(stars: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let americanMen = WorldCupResult.neverWon</span><br><span class="line">let americanWomen = WorldCupResult.winner(stars: 4)</span><br><span class="line">let japaneseMen = WorldCupResult.neverWon</span><br><span class="line">let japaneseWomen = WorldCupResult.winner(stars: 1)</span><br><span class="line"></span><br><span class="line">let teams = [americanMen, americanWomen, japaneseMen, japaneseWomen]</span><br><span class="line">let sortedByWins = teams.sorted()</span><br><span class="line">print(sortedByWins) // americanMen japaneseMen japaneseWomen americanWomen</span><br></pre></td></tr></table></figure></p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://mp.weixin.qq.com/s/nh5qifdneF_Y3xOJBy_ipg" target="_blank" rel="noopener">左耳朵耗子：什么是函数式编程？</a></p>
<p>因为新公司的项目使用一些 <strong>RxSwift</strong>，而自己本身对这块只是一知半解，希望今后能利用一些时间来把<strong>函数式响应式编程</strong>以及 <strong>MVVM</strong> 做一个系统的学习和实践，就以这篇耗子叔的<strong>函数式编程</strong>作为开始吧。</p>
<p>本文就<strong>函数式编程</strong>做了详细的介绍并配以生动的代码示例，从其历史到特点和应用的技术，还介绍了纯函数式语言 <strong>Scheme</strong>，最后通过对比的方式讲明了何为函数式编程思维方式。读了三遍，每次都有新的感受，让人迫不及待想去动手实践。😜</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/06/27/ARTS_week_4/" class="prev">PREV</a><a href="/2020/06/13/ARTS_week_2/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Hays Ren</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>