<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> ARTS 第四周 · Hays‘</title><meta name="description" content="ARTS 第四周 - Hays Ren"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hays‘"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/5343481486" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/roti13island" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/categories/" target="_self" class="nav-list-link">CATEGORIES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">ARTS 第四周</h1><div class="post-info">Jun 27, 2020</div><div class="post-content"><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode 21: 合并两个有序链表</a></p>
<blockquote>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最近周围好几个同学在面试某厂时都碰到这道题，虽然简单但要在规定时间内跑通还是对细节有点要求的。思路比较简单就直接写解答吧。</p>
<h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246%28v=pandp.10%29?redirectedfrom=MSDN" target="_blank" rel="noopener">The MVVM Pattern</a></p>
<p>本文出自微软，介绍了使用 <strong>MVVM</strong> 设计模式的动机，<strong>MVVM</strong> 是什么及其优势有哪些。</p>
<p><strong>MVVM</strong> 提供<strong>分离</strong>的概念，将应用的逻辑与视图清晰的分开有助于测试和维护，并使代码更易复用。数据的绑定为 <strong>View</strong> 和 <strong>ViewModel</strong>之间提供了联系。同时它让<strong>开发设计工作流</strong>和<strong>测试</strong>更加容易。</p>
<p><strong>MVVM</strong> 的三个核心组成分别为：<code>model</code>、<code>view</code>、<code>viewModel</code> ，文中将三者的作用及相互间的交互模式介绍的比较清晰。其中<code>viewModel</code>可视作<code>view</code>与<code>model</code>的中间人。</p>
<p>最后文中罗列了使用 <strong>MVVM</strong> 的优势有哪些，虽然 Windows Phone 已离我们远去，但毕竟 <strong>MVVM</strong> 是在微软诞生的，本文还是值得一看。</p>
<p>另外，与 <strong>iOS</strong> 中由 <strong>MVC</strong> 演化而来的 <strong>MVVM</strong> 还是有些区别的。</p>
<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周主要在处理业务代码，未能总结到 Tip ，惭愧惭愧。</p>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming/" target="_blank" rel="noopener">5 Things to Know About Reactive Programming</a></p>
<p>本文从五个方面介绍了理解<strong>响应式编程</strong>的要点，并用最流行的相应式框架 <strong>Rx</strong> 进行举例说明。</p>
<p><strong>响应式编程</strong>的核心是处理异步的数据流，数据流可分为“冷”和“热”两种，理解两者的区别十分重要。另外对异步的理解和代码的简洁和可读性的重视也是应该考虑的。最后文章梳理了<strong>响应式编程</strong>和<strong>响应式系统</strong>的区别。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/06/21/ARTS_week_3/" class="next">下一篇</a></div><div class="copyright"><p>© 2019 - 2020 <a href="http://yoursite.com">Hays Ren</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>