<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hays‘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-02T08:55:50.651Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hays Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 启动速度优化</title>
    <link href="http://yoursite.com/2021/03/01/ios_launch_optimize/"/>
    <id>http://yoursite.com/2021/03/01/ios_launch_optimize/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-03-02T08:55:50.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>在做优化前应将应用当前的耗时情况进行完善的统计，以便后续通过数据发现问题，以及对比优化效果。</p><p>我们的统计工作分位两个维度，一个是启动耗时的分段耗时及总耗时的统计，另一个是针对具体的启动项或函数的耗时进行统计及上报。</p><h3 id="启动耗时统计"><a href="#启动耗时统计" class="headerlink" title="启动耗时统计"></a>启动耗时统计</h3><p>我们将启动耗时分成两个阶段，第一阶段从系统创建 APP 进程（用户点击图标）到 <code>main</code> 函数开始执行，即 <strong>pre-main</strong> 阶段。第二阶段即从  <code>didFinishLaunching</code> 开始执行到首页渲染完毕。</p><p>至于 <code>main</code> 函数到 <code>didFinishLaunching</code> 开始这段耗时根据我们的统计占用耗时较少（约为几十毫秒）且浮动不大，因此将第二阶段的起点放在 <code>didFinishLaunching</code> 的开始，但在统计总体耗时的时候还是会将其包括在内。</p><h4 id="Pre-main-耗时统计"><a href="#Pre-main-耗时统计" class="headerlink" title="Pre-main 耗时统计"></a>Pre-main 耗时统计</h4><p>在调试时可以通过增加 <code>DYLD_PRINT_STATISTICS</code> 和 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 来打印出 <strong>dyld</strong> 的启动耗时，包括了各阶段的耗时及链接的动态库列表，但该耗时不包括加载 <strong>dyld</strong> 及之前的耗时。可以作为优化时的参考。</p><p>对于数据的上报，我们通过在 <code>main</code> 函数执行时通过 <code>sysctl</code> 函数去拿到进程创建的时间，具体如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)processInfoForPID:(<span class="keyword">int</span>)pid procInfo:(<span class="keyword">struct</span> kinfo_proc*)procInfo &#123;</span><br><span class="line">    <span class="keyword">int</span> cmd[<span class="number">4</span>] = &#123;<span class="built_in">CTL_KERN</span>, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size = <span class="keyword">sizeof</span>(*procInfo);</span><br><span class="line">    <span class="keyword">return</span> sysctl(cmd, <span class="keyword">sizeof</span>(cmd)/<span class="keyword">sizeof</span>(*cmd), procInfo, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimeInterval</span>)processStartTime &#123;</span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc kProcInfo;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> processInfoForPID:[[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        <span class="keyword">return</span> kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * <span class="number">1000.0</span> + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后以 <code>main</code> 函数开始执行作为 <strong>Pre-main</strong> 阶段的终点进行数据上报。</p><h4 id="After-main-耗时统计"><a href="#After-main-耗时统计" class="headerlink" title="After-main 耗时统计"></a>After-main 耗时统计</h4><p>以 <code>didFinishLaunching</code> 开始执行为起点，到首页渲染完成为终点。这里的终点会有几种打点方式，之前我们以首页的 <code>viewDidAppear</code> 首次调用作为首页渲染完成的标志，并在优化过程中将非必要启动项置于该方法的回调之后。但经过几个版本的数据分析（项目接入的 APM 监控）发现这块耗时会有较多的极端数据出现，且难以排查到具体原因和复现，因此我们决定修改该阶段终点的打点时机。</p><p>Apple 的 APM 统计 <strong>Metrics</strong> 框架将启动耗时的终点定在第一次 <code>CA::Transaction::commit</code>。而抖音的方案是根据 iOS 的版本，iOS 12 及以下使用 <code>viewDidAppear</code>，否则以 <code>applicationDidBecomeActive</code> 作为终点。</p><p>最终我们决定使用 <strong>Metrics</strong> 的做法，去监听 first <code>CA::Transaction::commit</code>，方式是通过 <strong>Runloop</strong> 来监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop]getCFRunLoop];</span><br><span class="line">if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">    CFRunLoopActivity activities = kCFRunLoopAllActivities;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, activities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        if (activity == kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            // 打点记录</span><br><span class="line">            CFRunLoopRemoveObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    CFRunLoopPerformBlock(mainRunloop, NSDefaultRunLoopMode, ^&#123;</span><br><span class="line">        // 打点记录</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>系统对于界面更新的处理方式是当 <code>UIView/CALayer</code> 发生属性变动、层级变动或设置了 <code>setNeedsLayout/setNeedsDisplay</code> 时，该 <code>UIView/CALayer</code> 会被标记为待处理并被提交到一个全局容器中。然后在通过 Runloop 中监听 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 两个事件，来处理被标记的视图变化，具体是调用了 <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 这个方法，其内部调用栈大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure></p><p>具体可参考 YY 关于 Runloop 的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">这篇文章</a>。</p><p>因此通过监听 Runloop 的事件可以拿到与第一次 <code>CA::Transaction::commit()</code> 非常接近的时间点。但经过实际测试发现，不同系统的回调时机会有较大的差异，不能简单的监听 Runloop 的第一次 <code>beforeWaiting</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// iOS 13.1.3</span><br><span class="line">kCFRunLoopBeforeTimers: 1088171.925382</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.049286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.062607</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.081497</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.094928</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.095982</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096508</span><br><span class="line">kCFRunLoopBeforeWaiting: 1088172.096728</span><br><span class="line">First View Did Appear: 1088172.154152</span><br><span class="line"></span><br><span class="line">// iOS 14.3</span><br><span class="line">First View Did Appear: 13255.515243</span><br><span class="line">kCFRunLoopBeforeTimers: 13255.545548</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.364940</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.365692</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.380215</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381132</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381725</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381765</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381807</span><br><span class="line">kCFRunLoopBeforeWaiting: 13257.381919</span><br></pre></td></tr></table></figure></p><p>可以看到在 iOS 13 上的表现基本符合预期，在提交了 Transaction 后的某个时间点首页渲染完成并调起了 <code>viewDidAppear</code> ，但在 iOS 14 上，Runloop 的回调会晚于 <code>viewDidAppear</code> 。</p><p>因此在该阶段终点即整个启动阶段的终点的打点时机上，如果想要监听 first <code>CA::Transaction::commit()</code>，需要对系统进行区分以获取最合理的时机，或者采用 first <code>viewDidAppear</code>加 first <code>applicationDidBecomeActive</code>的方式也是可以的。</p><h2 id="分阶段优化"><a href="#分阶段优化" class="headerlink" title="分阶段优化"></a>分阶段优化</h2><h3 id="Pre-main-阶段"><a href="#Pre-main-阶段" class="headerlink" title="Pre-main 阶段"></a>Pre-main 阶段</h3><p>通过 <code>DYLD_PRINT_STATISTICS</code> 可以比较清楚的看到该阶段内做了哪些事情以及它们的耗时情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 948.13 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 145.53 milliseconds (15.3%)</span><br><span class="line">        rebase/binding time: 113.82 milliseconds (12.0%)</span><br><span class="line">            ObjC setup time: 165.37 milliseconds (17.4%)</span><br><span class="line">           initializer time: 523.40 milliseconds (55.2%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :   5.35 milliseconds (0.5%)</span><br><span class="line">    libMainThreadChecker.dylib :  25.31 milliseconds (2.6%)</span><br><span class="line">          libglInterpose.dylib : 213.90 milliseconds (22.5%)</span><br><span class="line">              MyApp : 465.52 milliseconds (49.0%)</span><br></pre></td></tr></table></figure></p><p>其实在 dylib loading 开始前，系统会创建进程并为其开辟内存空间，然后加载可执行文件。之后加载 dyld（本身也是动态库），创建启动闭包（dyld3 ，更新 App 或重启手机后），完成后 dyld 开始分析动态库依赖，并逐一加载，即 <code>dylib loading time</code> 开始。加载完成后需对动态库进行符号绑定，即 <code>rebase/binding time</code>。因此动态库的数量是影响这段耗时的主要因素，包括系统库，而我们的项目已经全部采用静态库的方式。不但减少启动耗时，也可减少包体积。</p><p>之后的 <code>ObjC setup time</code> 的主要工作是 <code>Class</code> 注册、<code>Category</code> 注册（向类中插入方法）及方法唯一性检查等。这一段的优化工作主要在无用类及 <code>Category</code> 的检查上，之前常规的方案是通过 Mach-O 文件分析，取 <code>classlist</code> 与 <code>classref</code> 的差集，但这里推荐一个准确性更高的工具：<a href="https://github.com/wuba/WBBlades" target="_blank" rel="noopener">WBBlades</a>，通过分析 Mach-O 文件，解决了类的动态调用、类的继承关系和类内调用等问题。</p><p><code>initializer time</code> 中主要是 <code>+load()</code> 方法调用、<strong>c++</strong> 构造函数和静态全局变量的创建。而 <code>+load()</code> 方法除了本身的耗时，还会触发 Page in 读入物理内存以执行该函数。从上面的 log 可以看到这段耗时占到整个 Pre-main 耗时的一半以上，因此针对 <code>+load()</code> 方法的优化就是尽可能不用该方法，改为 <code>+initialize()</code>等懒加载的方式。对于 <strong>c++</strong> 的静态初始化，可将 <code>static</code> 变量迁移至方法内部以改为懒加载的方式，借鉴<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487757&amp;idx=1&amp;sn=a52c11f6a6f217bd0d3283de9b00c8bc&amp;chksm=e9d0daefdea753f954cfcb15d5d0f90302a9f45ba06968377644ffe9e5757a69c5b0132d2c8b&amp;mpshare=1&amp;scene=1&amp;srcid=0125oJOAovQbQckW9TdR8cTn&amp;sharer_sharetime=1611540323121&amp;sharer_shareid=4e61187060391b97449b816517d4ddd7&amp;version=3.0.31.6162&amp;platform=mac#rd" target="_blank" rel="noopener">这篇</a>的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="After-main-阶段"><a href="#After-main-阶段" class="headerlink" title="After-main 阶段"></a>After-main 阶段</h3><p>该阶段的优化重点是启动项、首页的初始化及生命周期方法。</p><h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><p>启动项的治理思路比较简单，将非必要的启动项通过置后、异步或懒加载等方式来减少耗时。</p><p>另外，可以针对启动项进行统一管理，如耗时统计，包括线下 log 及线上监控，在我们的优化过程中发现仅以本地 log 作为依据是无法完全覆盖所有的启动场景的，在上线了线上监控后发现某些启动项耗时会有很大的波动，出现较高的耗时。在了解启动项耗时的基本情况后，再对高耗时的启动项进行摸排，找到具体耗时原因进行优化。</p><p>启动项统一管理的作用还包括解决启动依赖、控制并发、更好的管控新增的启动项等。</p><h4 id="首页耗时"><a href="#首页耗时" class="headerlink" title="首页耗时"></a>首页耗时</h4><p>这一阶段的主要工作包括首页及相关页面对子视图的加载渲染、网络请求、数据同步、各配置项的同步及组件的初始化等等。对于这段耗时的监控我们借助了 Instrument 的 Time Profiler 以及本地打点的方式。其中 Time Profiler 使用的时定期抓取主线程堆栈的方式，间隔为 1ms ，通过对线程快照的对比来进行耗时统计。如果觉得 Time Profiler 粒度太粗也可以自行设置间隔来抓取主线程的堆栈，如通过 <code>Thread.callStackSymbols</code> 或 <code>__builtin_frame_address</code>取到当前栈帧的地址，通过 <code>dladdr(UnsafeRawPointer(bitPattern: address), &amp;i)</code> 得到该栈帧的 <code>dl_info</code>，该结构体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public struct dl_info &#123;</span><br><span class="line">public var dli_fname: UnsafePointer&lt;Int8&gt;! //* Pathname of shared object *//</span><br><span class="line">public var dli_fbase: UnsafeMutableRawPointer! //* Base address of shared object *//</span><br><span class="line">    public var dli_sname: UnsafePointer&lt;Int8&gt;! //* Name of nearest symbol *//</span><br><span class="line">    public var dli_saddr: UnsafeMutableRawPointer! //* Address of nearest symbol *//</span><br><span class="line">    public init()</span><br><span class="line">    public init(dli_fname: UnsafePointer&lt;Int8&gt;!, dli_fbase: UnsafeMutableRawPointer!, dli_sname: UnsafePointer&lt;Int8&gt;!, dli_saddr: UnsafeMutableRawPointer!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>dli_sname</code>即为符号名。最后通过 <code>Frame Pointer</code> 的偏移来遍历整个调用栈的符号。</p><p>另一种思路是直接对方法进行打点，比较容易想到的是 hook <code>objc_msgsend</code>，但弊端是静态函数记录不到，如纯 Swift 方法。也可在编译期通过对代码进行插桩实现打点，如利用 Clang 提供的代码覆盖工具 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs" target="_blank" rel="noopener">SanitizerCoverage</a>，可覆盖 OC/Swift/C/C++ 等语言。</p><p>具体的耗时情况及解决办法也是因项目而异的，比较通用的耗时点比如子视图的加载，在我们的项目中使用了 <code>MJRefreshGifHeader</code> , 并在其初始化时从 bundle 中分别取了 15 至 20 张图片传至 GifHeader 中不同的状态，造成了大量的耗时。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h3><blockquote><p>页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。  </p></blockquote><p>每触发 Page fault 都会有一定的耗时（一次约 0.6~0.8 ms），当触发量足够多时其耗时也是比较可观的。具体消耗可通过 <strong>Instruments</strong> 的 System Trace 查看，注意这个消耗不是恒定的，受系统内存使用情况的影响，因此在测试前可重启手机，或打开多个 App 来尽量占用系统内存。</p><p>Xcode 在 Build Settings - Linking - Order File 中提供了一个设置 Order file 的路径。该文件是一个<code>.order</code>后缀的文本文件，链接器会根据该文件改变其中符号在内存中的布局，且会置于对应 section 的开始，对于不存在的符号会选择忽略。</p><p>通过将启动过程中所使用的函数符号通过 order file 告知链接器进行重排，将它们尽量排在相邻靠前的内存页中，从而减少 Page fault 触发次数，进而减少启动耗时。</p><p>因此重排的终点就是生成覆盖面尽量全的 order file。</p><p>我们采用的方式是 Clang 提供的 SanitizerCoverage，也就是编译期插桩的方式。该方案的优势在于覆盖面广（OC/Swift/C++，method/function/block），侵入性小，开发成本少（有很多现成的方案可借鉴，实现都大同小异）。将启动到首页显示期间运行的函数符号记录在 order file 中，然后放入项目路径下，可通过 LinkMap 来对比使用前后的符号排列是否变化。</p><p>至于具体的优化效果，本地测试下来成效不是很明显。而且本身对二进制重排并没有抱多少期望，只是在做完基础优化工作后的额外尝试，效果有点算点吧~</p><h3 id="TEXT-段重命名"><a href="#TEXT-段重命名" class="headerlink" title="__TEXT 段重命名"></a>__TEXT 段重命名</h3><p>因为 App Store Connect 会对我们上传 Mach-O 的 Text 段进行加密，以防止代码的泄露。而在启动过程会触发大量的 Page in 动作，其中包括将 Text 段的页读入物理内存，这就需要先对其解密，从而产生耗时以及 Text 段的体积变大。（此过程已在 iOS 13 被优化，Page in 不需要再解密了）</p><p>如果你的应用仍支持 iOS 13 以下的版本，比如我们还在 iOS 9 😓 。可以尝试一下段重命名的方案。链接器 ld 的 <code>-rename-section</code> 命令可以将 Text 段的内容移至其它的段，从而规避解密的耗时。具体可看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487459&amp;idx=1&amp;sn=3dd9276f5af78ca5a377adec37e3e916&amp;chksm=e9d0c401dea74d17e9f1bdd5ea764cc0cd7e845c6ebadde752d36608306b09e762a1681c7252&amp;scene=178&amp;cur_album_id=1665528287604817930#rd" target="_blank" rel="noopener">这篇</a>，跟重排一样，不用抱太大希望，不过对包大小的优化效果还是有的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据统计&quot;&gt;&lt;a href=&quot;#数据统计&quot; class=&quot;headerlink&quot; title=&quot;数据统计&quot;&gt;&lt;/a&gt;数据统计&lt;/h2&gt;&lt;p&gt;在做优化前应将应用当前的耗时情况进行完善的统计，以便后续通过数据发现问题，以及对比优化效果。&lt;/p&gt;
&lt;p&gt;我们的统计工作分
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第五周</title>
    <link href="http://yoursite.com/2020/07/05/ARTS_week_5/"/>
    <id>http://yoursite.com/2020/07/05/ARTS_week_5/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-07-05T14:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/submissions/" target="_blank" rel="noopener">LeetCode 225：用队列实现栈</a></p><blockquote><p>使用队列实现栈的下列操作：<br>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空  </p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题主要考察<strong>栈</strong>这个数据结构的特性，比较简单。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> queue: [<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        queue = [<span class="type">Int</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> x: Int)</span></span> &#123;</span><br><span class="line">        queue.append(x)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !queue.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.popLast() ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">top</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !queue.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.last ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="http://rx-marin.com/post/bind-multiple-cells/" target="_blank" rel="noopener">Binding to a table view with multiple cells and sections</a></p><p>本篇文章介绍了两种使用<code>RxSwift</code>将<code>tableView</code>与多种类型的 cell 和 section 绑定的方式。一种是用<code>RxCocoa</code>的<code>bind(to:)</code>，好处是不需添加额外依赖且逻辑简单，但无法绑定 section，另一种是使用<code>RxDataSources</code>，可适用多重 cell 和 section 的场景，也是笔者比较推荐的方式。</p><p>本文以简单例子介绍了如何将数据流绑定到<code>tableView</code>上，算是一篇比较好的上手材料。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>记录一个手势处理的问题，场景是一个自定义弹层添加了<code>UISwipeGestureRecognizer</code>的手势，目的是在用户左滑 pop 的时候可以拦截该手势并将弹层 dismiss，否则会出现 controller 被 pop 后弹层仍在显示的问题。</p><p>但实际发现并不能有效拦截该手势，猜测是系统的 gesture distance 更小，故处理方式为添加一个代理方法以达到手势<strong>并行</strong>处理的效果：<br><code>gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</code></p><p>这样自行注册的<code>UISwipeGestureRecognizer</code>便可同时相应事件了。</p><p>同时，当遇到手势冲突需要<strong>取舍</strong>时，可以试试以下两个代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 返回 true 时，gestureRecognizer 会失效</span><br><span class="line">func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</span><br><span class="line"></span><br><span class="line">// 返回 true 时，otherGestureRecognizer 会失效</span><br><span class="line">func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://wetest.qq.com/lab/view/367.html" target="_blank" rel="noopener">iOS微信内存监控</a></p><p>本篇文章出自微信测试团队，背景是当时微信的日志无法正确反映 FOOM (Foreground Out Of Memory)的具体原因，从而开发的一款内存监控工具，介绍了实现原理、误判降低以及最后成果。</p><p>过程中有许多亮点值得学习，比如对 libmalloc 接口的使用、为了降低数据大小而对数据结构的选择以及如何减少误判的思路等等。</p><p>目前公司也准备开发一个数据上报组件，因此分享这篇文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第四周</title>
    <link href="http://yoursite.com/2020/06/27/ARTS_week_4/"/>
    <id>http://yoursite.com/2020/06/27/ARTS_week_4/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-06-28T13:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode 21: 合并两个有序链表</a></p><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最近周围好几个同学在面试某厂时都碰到这道题，虽然简单但要在规定时间内跑通还是对细节有点要求的。思路比较简单就直接写解答吧。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246%28v=pandp.10%29?redirectedfrom=MSDN" target="_blank" rel="noopener">The MVVM Pattern</a></p><p>本文出自微软，介绍了使用 <strong>MVVM</strong> 设计模式的动机，<strong>MVVM</strong> 是什么及其优势有哪些。</p><p><strong>MVVM</strong> 提供<strong>分离</strong>的概念，将应用的逻辑与视图清晰的分开有助于测试和维护，并使代码更易复用。数据的绑定为 <strong>View</strong> 和 <strong>ViewModel</strong>之间提供了联系。同时它让<strong>开发设计工作流</strong>和<strong>测试</strong>更加容易。</p><p><strong>MVVM</strong> 的三个核心组成分别为：<code>model</code>、<code>view</code>、<code>viewModel</code> ，文中将三者的作用及相互间的交互模式介绍的比较清晰。其中<code>viewModel</code>可视作<code>view</code>与<code>model</code>的中间人。</p><p>最后文中罗列了使用 <strong>MVVM</strong> 的优势有哪些，虽然 Windows Phone 已离我们远去，但毕竟 <strong>MVVM</strong> 是在微软诞生的，本文还是值得一看。</p><p>另外，与 <strong>iOS</strong> 中由 <strong>MVC</strong> 演化而来的 <strong>MVVM</strong> 还是有些区别的。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周主要在处理业务代码，未能总结到 Tip ，惭愧惭愧。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming/" target="_blank" rel="noopener">5 Things to Know About Reactive Programming</a></p><p>本文从五个方面介绍了理解<strong>响应式编程</strong>的要点，并用最流行的相应式框架 <strong>Rx</strong> 进行举例说明。</p><p><strong>响应式编程</strong>的核心是处理异步的数据流，数据流可分为“冷”和“热”两种，理解两者的区别十分重要。另外对异步的理解和代码的简洁和可读性的重视也是应该考虑的。最后文章梳理了<strong>响应式编程</strong>和<strong>响应式系统</strong>的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第三周</title>
    <link href="http://yoursite.com/2020/06/21/ARTS_week_3/"/>
    <id>http://yoursite.com/2020/06/21/ARTS_week_3/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-21T14:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 287: 寻找重复数</a></p><blockquote><p>给定一个包含<code>n + 1</code>个整数的数组<code>nums</code>，其数字都在 1 到 n之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>示例 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>该算法可用<strong>二分法</strong>、<strong>二进制</strong>或<strong>快慢指针</strong>等等方法来解，本次主要记录一下<strong>快慢指针</strong>的方法。<br><strong>快慢指针</strong>的方法主要借鉴了 <strong>Floyd 判圈算法</strong>，该算法主要用于检测链表是否有环。在本题中对<code>nums</code>建图，可将问题等价为： <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode142:  环形链表 II</a>  ，可分别设置快慢指针，慢指针每次走一步，快指针每次走两步，根据 <strong>Floyd 判圈算法</strong>两指针在有环的情况下一定会相遇，相遇后将慢指针放置起点，然后两个指针每次同时走一步，相遇点便是答案。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> slow = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow)</span><br><span class="line"></span><br><span class="line">    slow = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://allegro.tech/2014/12/swift-method-dispatching.html" target="_blank" rel="noopener">Swift Method Dispatching</a></p><p><strong>Swift</strong> 作为一门静态语言，其在方法派发上的性能表现要强于 <strong>OC</strong> 不少，本文中主要介绍了 <strong>Swift</strong> 的方法派发机制。</p><p>在 <strong>OC</strong> 中，<strong>clang</strong> 会将方法调用翻译成对<code>objc_msgSend</code>这个函数的调用，传入相应的<code>target</code>、<code>SEl</code>以及参数，该方法是由汇编实现的，负责<strong>OC</strong>中的方法派发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id obj, SEL op, … )</span><br><span class="line">&#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line">    IMP imp = CacheLookup(c, op);</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        imp = class_getMethodImplementation(c, op);</span><br><span class="line">    &#125;</span><br><span class="line">    jump imp(obj, op, …);]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，影响效率的最大因素在于找到具体的方法实现<code>IMP</code>，如果方法缓存命中，那么效率上基本等同于在<code>hashMap</code>中取值，这种情况还好，但如果未命中，则需要去沿着继承体系在类的方法列表中寻找对应的实现并加入缓存，再跳到该实现执行具体函数，这样的派发方式相对较慢。因此<code>objc_msgSend</code>也被称为跳板函数。</p><p>在 <strong>Swift</strong> 中，使用了 <strong>Virtual Method Table</strong> 来支持运行时的方法绑定，文章通过对 <strong>SIL</strong> 的分析发现 <strong>vtable</strong> 本质上是一个 key 为方法名，value 为方法实现的字典，而通过汇编代码可以看到 <strong>Swift</strong> 代码几乎做到了将调用方法直接映射到处理器指令，并将调用对象存入寄存器中。通过传入对象中指向 <code>metadata</code> 的指针找到保存其类信息的结构体，进而通过偏移量找到相应的方法。</p><p>当打开编译期优化选项后，<strong>Swift</strong> 代码执行速度可能更快，原因在于：</p><ul><li>当编译器知道目标对象的具体类型后，non-final 方法可被直接调用</li><li>编译期会用内联的方式直接将方法实现内联至方法调用的地方，从而省去了函数调用的开销</li></ul><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周依旧记录 <strong>Swift</strong> 的新特性，版本来到<code>5.3</code>。</p><h4 id="Multi-pattern-catch-clauses"><a href="#Multi-pattern-catch-clauses" class="headerlink" title="Multi-pattern catch clauses"></a>Multi-pattern catch clauses</h4><p>简单来说，一个<code>catch</code>代码块可以 handle 多种错误类型了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureError: Error &#123;</span><br><span class="line">    case tooCold, tooHot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let result = try checkReactorOperational()</span><br><span class="line">    print(“Result: \(result)”)</span><br><span class="line">&#125; catch TemperatureError.tooHot, TemperatureError.tooCold &#123;</span><br><span class="line">    print(“Shut down the reactor!”)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(“An unknown error occurred.”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Multiple-trailing-closures"><a href="#Multiple-trailing-closures" class="headerlink" title="Multiple trailing closures"></a>Multiple trailing closures</h4><p>多个尾随闭包也被支持了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Before</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Synthesized-Comparable-conformance-for-enums"><a href="#Synthesized-Comparable-conformance-for-enums" class="headerlink" title="Synthesized Comparable conformance for enums"></a>Synthesized Comparable conformance for enums</h4><p>实现<code>Comparable</code>的枚举可以用来比大小了，如果带有的关联值也是<code>Comparable</code>的话，也是可以比的哦~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum WorldCupResult: Comparable &#123;</span><br><span class="line">    case neverWon</span><br><span class="line">    case winner(stars: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let americanMen = WorldCupResult.neverWon</span><br><span class="line">let americanWomen = WorldCupResult.winner(stars: 4)</span><br><span class="line">let japaneseMen = WorldCupResult.neverWon</span><br><span class="line">let japaneseWomen = WorldCupResult.winner(stars: 1)</span><br><span class="line"></span><br><span class="line">let teams = [americanMen, americanWomen, japaneseMen, japaneseWomen]</span><br><span class="line">let sortedByWins = teams.sorted()</span><br><span class="line">print(sortedByWins) // americanMen japaneseMen japaneseWomen americanWomen</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://mp.weixin.qq.com/s/nh5qifdneF_Y3xOJBy_ipg" target="_blank" rel="noopener">左耳朵耗子：什么是函数式编程？</a></p><p>因为新公司的项目使用一些 <strong>RxSwift</strong>，而自己本身对这块只是一知半解，希望今后能利用一些时间来把<strong>函数式响应式编程</strong>以及 <strong>MVVM</strong> 做一个系统的学习和实践，就以这篇耗子叔的<strong>函数式编程</strong>作为开始吧。</p><p>本文就<strong>函数式编程</strong>做了详细的介绍并配以生动的代码示例，从其历史到特点和应用的技术，还介绍了纯函数式语言 <strong>Scheme</strong>，最后通过对比的方式讲明了何为函数式编程思维方式。读了三遍，每次都有新的感受，让人迫不及待想去动手实践。😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第二周</title>
    <link href="http://yoursite.com/2020/06/13/ARTS_week_2/"/>
    <id>http://yoursite.com/2020/06/13/ARTS_week_2/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-14T14:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode 63: 不同路径</a></p><blockquote><p>一个机器人位于一个 <em>m x n</em>网格的左上角 。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="ARTS_week_2/robot_maze.png" alt><br> 网格中的障碍物和空位置分别用 1 和 0 来表示。<br><strong>说明：*</strong>m<em> 和 </em>n*的值均不超过 100。<br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>问题，从这类问题的解法考虑，首先应寻找<strong>最优子结构</strong>，然后写出<strong>状态转义方程</strong>并将其翻译为代码。<br>在本题中，<strong>最优子结构</strong>应是每个格子的不同可达路径数，<strong>边界条件</strong>为第一行和第一列中每个格子的可达路径数，因为其中的每个格子都可根据左一个或上一个格子直接得出，而最关键的<strong>状态转义方程</strong>应为：<code>格子的路径数 = 上一个格子的路径数 + 左一个格子的路径数</code><br>注：矩阵默认保存的数据为 0 或 1 即表示是否有障碍，但经算法遍历填充后为每个格子的不同路径数</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="number">_</span> obstacleGrid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> grid = obstacleGrid</span><br><span class="line">        <span class="keyword">let</span> column = obstacleGrid.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> row = obstacleGrid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = (grid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = (grid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">                <span class="keyword">if</span> grid[<span class="built_in">c</span>][r] == <span class="number">0</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = grid[<span class="built_in">c</span>-<span class="number">1</span>][r] + grid[<span class="built_in">c</span>][r-<span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[column-<span class="number">1</span>][row-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.callstats.io/blog/2018/05/16/explaining-webrtc-secure-real-time-transport-protocol-srtp" target="_blank" rel="noopener">Explaining the WebRTC Secure Real-Time Transport Protocol (SRTP)</a></p><p>本周在准备分享有关 WebRTC 的内容，之前对于 WebRTC 的协议栈并没有做过深入了解，正好趁此机会做一次补充。</p><p>本篇文章从 <strong>SRTP</strong> 协议入手，介绍了 <strong>RTP</strong> 协议栈的组成，以及 WebRTC 所使用的加密协议等。</p><p><strong>SRTP (Secure Real-Time Transport Protocol)</strong> 协议是对 <a href="https://tools.ietf.org/html/rfc3550" target="_blank" rel="noopener">RTP</a> 协议的拓展并提供了一系列的加密机制，以提升 RTP 协议的安全性。包括对 <strong>RTC</strong> 包的加密、数据源认证、密钥管理等。</p><p><strong>SRTP</strong> 使用 AES （一种被广泛应用的对称加密算法）作为数据加密算法，包含两种加密模式：Segmented Integer Counter Mode 和 f8-mode。</p><p>对于消息完整性的保证，<strong>SRTP</strong> 使用算法为数据包和部分包头创建认证标识（authentication tag），并将其添加到 <strong>RTC</strong> 包上。该标识用于数据包内容的验证以防止数据伪造。同时，认证还通过为每个数据包提供可序列可比较的下标以防止回复攻击。在 WebRTC 中，<strong>SRTP</strong> 为保证消息完整性使用了 HMAC-SHA1 算法。</p><p>为保障每个 session 的安全性，<strong>SRTP</strong> 使用密钥派生函数，基于 master key 生成一些派生 keys ，对每个独立 session 使用唯一的 key 以保证 session 的安全。</p><p>WebRTC 通过 <strong>SRTP-DTLS</strong> 协议以保证流的安全性，其中，<strong>SRTP</strong> 用于媒体流的加密，<strong>DTLS</strong> 用于用于数据流的加密。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周记录一下 <strong>Swift</strong> 5.2 在语言特性上的更新，本次的两个更新都与函数相关，函数在 <strong>Swift</strong> 中的地位和作用是非常重要的</p><p><strong>函数式的类型调用</strong><br>无论在类、结构体还是协议中，如果想以函数式的调用方式来调用对象，进而调用对象中的某个方法，可以通过在类型中声明方法：<code>callAsFunction()</code>来做到，以<code>class</code>为例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> color: <span class="type">UIColor</span> = .white</span><br><span class="line"><span class="keyword">var</span> mileAge: <span class="type">UInt</span> = <span class="number">0</span></span><br><span class="line">. . .</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callAsFunctions</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">info(band)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line"><span class="comment">// call as func</span></span><br><span class="line">car(“<span class="type">BMW</span>”)</span><br></pre></td></tr></table></figure></p><p><strong>使用 key paths 作为函数</strong><br>在 <strong>Swift</strong>5.2 中，可使用 <strong>key path</strong> 作为函数传参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let fruits: [Fruit] = . . .</span><br><span class="line"></span><br><span class="line">// before</span><br><span class="line">fruites.map&#123; $0.color &#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line">fruites.map(\.color)</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://draveness.me/whys-the-design-live-streaming-latency/" target="_blank" rel="noopener">为什么流媒体直播的延迟很高</a></p><p>在本周公司内部分享 <strong>WebRTC</strong> 时被同事问到 <strong>WebRTC</strong> 与 <strong>HLS</strong> 的区别，我的理解是从底层的协议到框架的设计和目标应用场景均有不同，前者的目标是点对点的实时通讯，而后者被设计为流媒体传输协议。但 <strong>WebRTC</strong> 也可被应用到直播场景中，需要额外搭建服务通讯模型。两者在直播场景下的表现如何还需深入了解。</p><p>本文从流媒体直播的链路入手分析，分析数据编码、数据传输、缓存等方面可能造成延迟的原因。对了解流媒体直播的链路有一定的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第一周</title>
    <link href="http://yoursite.com/2020/06/06/ARTS_week_1/"/>
    <id>http://yoursite.com/2020/06/06/ARTS_week_1/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-14T14:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode 70: 爬楼梯</a></p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢?<br><strong>注意：</strong>给定 n 是一个正整数。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>的题目，<strong>动态规划</strong>的核心思想是利用过去的结果解决未来的问题。即将问题分解为相对简单的<strong>子问题</strong>，顺序求解并保存结果，为下一子问题的求解提供信息。类似数学中的<strong>递推法</strong>。<br>对于本题，当总台阶数为 1 时，到达楼顶的方法为 1 ，总台阶数为 2 时，到达楼顶的方法为 2 。这便是我们已有解的<strong>子问题</strong>，下一步就是如何通过已知的条件去解决目标问题。对于本题而言，总台阶数为 n 的问题的解等于总台阶数为<code>n - 1</code>与<code>n - 2</code>的解的<strong>和</strong>，因为前两个台阶到达目标台阶的方式唯一且互斥（走 1 步或 2 步）。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> n &#125; <span class="comment">// n = 1, n = 2</span></span><br><span class="line"><span class="keyword">var</span> solutions = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">3</span> … n &#123;</span><br><span class="line">solutions.append(solutions[index-<span class="number">1</span>] + solutions[index-<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> solutions[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>时间复杂度：<strong>O(n)</strong>，空间复杂度：<strong>O(n)</strong></li></ul><hr><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" target="_blank" rel="noopener">When to Use Swift Structs and Classes</a></p><p>本文是一篇老文章了，来自<a href="https://www.mikeash.com/" target="_blank" rel="noopener">Mike Ash</a> 。因为之前在面试中常被问到<code>class</code>与<code>struct</code>的区别。所以想分享一下这篇文章。<br>其实最大的区别就是语义上的区别了，也是本文着重想要表达、同时也是我们日常使用时最应注意的问题：</p><blockquote><p><code>struct</code>是值类型，<code>class</code>是引用类型</p></blockquote><p>语义上的区别背后是两者存储方式的不同，<code>struct</code>存储在<strong>栈</strong>上，<code>class</code>存储在<strong>堆</strong>上，而<code>class</code>的引用保存在<strong>栈</strong>上。</p><p>对于<strong>值类型</strong>，当你对数据进行赋值时，你得到的是该数据的拷贝。而对于<strong>引用类型</strong>，你得到的将是对该数据引用的拷贝。</p><p>文中还对<strong>值语义</strong>进行了探讨，虽然很多语言坚持“万物皆对象”，甚至数字都是<strong>引用类型</strong>的，但它们不免会使用<code>不可变类型</code>，对于这样的类型而言，<strong>值/引用</strong>的区别消失了，或者说区别仅仅在于性能表现上了。</p><p>如何选择<strong>值类型</strong>或<strong>引用类型</strong>的核心问题在当数据被赋值后你希望得到一份数据的拷贝还是一份引用的拷贝，这就需要在具体的场景中分析了。</p><p>对于<strong>嵌套类型</strong>，有以下四种情况：</p><ul><li><strong>引用类型</strong>中包含<strong>引用类型</strong><br>并无特殊表现，持有外部或内部的引用均可改变该引用指向的值，且都可感知数据变化</li><li><strong>值类型</strong>中包含<strong>值类型</strong><br>并无特殊表现，嵌套的<strong>值类型</strong>被赋值时均会拷贝其内容</li><li><strong>引用类型</strong>中包含<strong>值类型</strong><br>外部的<strong>引用</strong>被赋值时，内部的<strong>值</strong>会被拷贝</li><li><strong>值类型</strong>中包含<strong>引用类型</strong><br>这种情况会破坏<strong>值语义</strong>，当外部数据被赋值时，内部数据仅会拷贝其引用。</li></ul><hr><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周因为刚入职，主要在配置环境和熟悉文档😂。所以记录下 SSH key 的生成：</p><ol><li>在终端输入<code>ssh-keygen</code></li><li>确认默认路径<code>.ssh/id_rsa</code></li><li>输入密码，也可跳过</li><li>打开 ssh 公钥文件：<code>~/.ssh/id_rsa.pub</code>，复制其中内容</li><li>粘贴至相应平台如 github </li></ol><blockquote><p>SSH 为 Secure Shell（安全外壳协议） 的缩写，是一种加密的网络传输协议。该协议在网络创建<strong>安全隧道</strong>来实现 SSH 客户端与服务端的连接。<br>以<strong>非对称加密</strong>的方式身份验证。  </p></blockquote><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="http://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code" target="_blank" rel="noopener">如何阅读别人的代码</a>  </p><p>该篇文章出自垠神，因为上周刚刚接手项目，首要任务就是熟悉业务和代码。当然垠神跟我等菜鸡的关注点肯定是不同的，他的方式也不一定适用，因此算是借题发挥吧。  </p><p>首先要了解的是项目的整体框架和工程的组织结构，一般主工程会按照业务模块划分，当然也可能会包括一些工具类或三方的组件啥的。另外工程的配置、引入的<code>framework</code>或<code>library</code>也应该了解一下。有些项目还会混编 <code>Objective-c</code>和<code>Swift</code>。如果能用类图或思维导图将项目框架构建出来肯定是更好的。  </p><p>一般 iOS 工程会用第三方的库管理工具如 CocoaPods ，因此需要了解项目使用了哪些第三方库，在 iOS 中许多应用方向的三方库都具有“垄断”地位，如<code>AFNetworking</code>、<code>FMDB</code>、<code>Masonry</code>等等，因此了解这些三方库的使用及实现就非常重要，即使项目中对其进行二次封装也可以很快上手。  </p><p>接下来就是代码的熟悉了，有些公司会有代码规范的要求或接入了规范检查工具，因此最好先了解下具体要求。另外就要看看是否有编程范式的要求或使用了某些框架如<code>Rx</code>、<code>PromiseKit</code>啥的。  </p><p>当然只看不写效果不会太好，最好从模块业务或组件入手去实际开发，多和同事沟通，多请大伙给你 code review ，慢慢从点扩展到面，一定会很快上手的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
</feed>
