<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hays‘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-06-06T03:48:03.008Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hays Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Associated Objects 实现及 weak 方案</title>
    <link href="http://yoursite.com/2021/06/02/Associated_Objects/"/>
    <id>http://yoursite.com/2021/06/02/Associated_Objects/</id>
    <published>2021-06-01T16:00:00.000Z</published>
    <updated>2021-06-06T03:48:03.008Z</updated>
    
    <content type="html"><![CDATA[<p>Associated Objects 是 OC Runtime 2.0 中的特性之一，提供了为既有类动态添加关联对象的能力，也是对 category 只能拓展行为的一个很好的补充。它通过 Key-Value 的形式将对象与类绑定，并提供类似属性的关联策略，最终保存在全局的 Hash map 中。本文尝试从源码分析 Associated Objects 的实现及其能与不能，并通过一种 walk around 的方式实现 weak Associated Objects 。</p><blockquote><p>源码版本：objc4-818  </p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们熟悉的 runtime 提供的关联对象的 API 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><br><span class="line"></span><br><span class="line">id objc_getAssociatedObject(id object, const void *key)</span><br><span class="line"></span><br><span class="line">void objc_removeAssociatedObjects(id object)</span><br></pre></td></tr></table></figure></p><p>一对 set/get 方法和一个移除全部关联对象的方法，下面来逐个分析。</p><h3 id="Set-Associated-Object"><a href="#Set-Associated-Object" class="headerlink" title="Set Associated Object"></a>Set Associated Object</h3><p><code>objc_setAssociatedObject()</code>方法内部调用了<code>_object_set_associative_reference()</code>，将参数透传。<code>_object_set_associative_reference</code>的实现在 objc-references.mm 文件中。该文件包含了 ObjC 关联对象的相关实现，<code>ObjcAssociation</code>类是对关联对象的封装，包括关联策略（policy）以及 value 、初始化方法以及一些内部方法，这里包括根据不同关联策略对 value 的处理。<code>AssociationsManager</code>主要用来管理 Association Map 及相关的锁（spinlock_t）操作。</p><p>关于 hash map 可以看下下面的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef DenseMap&lt;const void *, ObjcAssociation&gt; ObjectAssociationMap;</span><br><span class="line">typedef DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, ObjectAssociationMap&gt; AssociationsHashMap;</span><br></pre></td></tr></table></figure></p><p>可以看到关联对象是通过二层 map 来保存的，每个对象的关联对像保存在 <code>ObjectAssociationMap</code> 中，而所有对象的 <code>ObjectAssociationMap</code> 被保存在全局的 <code>AssociationsHashMap</code> 中。</p><p>注意到这里用到了一个数据结构 <code>DenseMap</code> ，它经常在 ObjC runtime 中出现，该结构是一个基于二次探查法的 hash map ，具体实现在 llvm-DenseMap.h 中。</p><p>下面回到<code>_object_set_associative_reference()</code>的实现上来，首先：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_set_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, <span class="keyword">uintptr_t</span> policy)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This code used to work when nil was passed for object and key. Some code</span></span><br><span class="line">    <span class="comment">// probably relies on that to not crash. Check and handle it explicitly.</span></span><br><span class="line">    <span class="comment">// rdar://problem/44094390</span></span><br><span class="line">    <span class="keyword">if</span> (!object &amp;&amp; !value) <span class="keyword">return</span>;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里限定了 object 和 value 不得同时为 nil ，其实在 runtime.h 中对 object 和 key 参数添加了 <code>_Nonnull</code> 约束，显示传入 nil 编译器会警告，但就算 object 传入 self 也可能会有 nil 的情况，这时会得到运行时错误：EXC_BAD_ACCESS ，而 key 为 nil 时会关联失败。当 value 为 nil 时，这个关联对象会被 erase ，即移除了该 key 下的关联，具体做法后面会看到。</p><p>下面是对禁止添加关联对象的宏进行检查：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (object-&gt;getIsa()-&gt;forbidsAssociatedObjects())</span><br><span class="line">_objc_fatal(<span class="string">"objc_setAssociatedObject called on instance (%p) of class %s which does not allow associated objects"</span>, object, object_getClassName(object));</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">forbidsAssociatedObjects</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (data()-&gt;flags &amp; RW_FORBIDS_ASSOCIATED_OBJECTS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面开始创建存入 hash map 的 key 和 value ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">DisguisedPtr&lt;objc_object&gt; disguised&#123;(objc_object *)object&#125;;</span><br><span class="line">ObjcAssociation association&#123;policy, value&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，key 的类型为 <code>DisguisedPtr&lt;T&gt;</code> ，其作用是通过 <code>disguised</code> 方法获得指向 object 的指针（uintptr_t）。而 value 就是我们之前提到的 <code>ObjcAssociation</code> ，将 policy 和 value 封装其中。</p><p>然后根据 policy 对 value 进行内存管理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    association.acquireValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ObjcAssociation</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">acquireValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_value) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (_policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">                    _value = objc_retain(_value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">                    _value = ((id(*)(id, SEL))objc_msgSend)(_value, @selector(copy));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来通过 <code>AssociationsManager</code> 获取全局的 <code>AssociationsHashMap</code> ，manager 在初始化时会加锁:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">AssociationsManager manager;</span><br><span class="line"><span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来是插入操作，实现上还是比较简单的，可直接看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">if (value) &#123;</span><br><span class="line">         auto refs_result = associations.try_emplace(disguised, ObjectAssociationMap&#123;&#125;);</span><br><span class="line">         if (refs_result.second) &#123;</span><br><span class="line">             /* it&apos;s the first association we make */</span><br><span class="line">             isFirstAssociation = true;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         /* establish or replace the association */</span><br><span class="line">         auto &amp;refs = refs_result.first-&gt;second;</span><br><span class="line">         auto result = refs.try_emplace(key, std::move(association));</span><br><span class="line">         if (!result.second) &#123;</span><br><span class="line">             association.swap(result.first-&gt;second);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         auto refs_it = associations.find(disguised);</span><br><span class="line">         if (refs_it != associations.end()) &#123;</span><br><span class="line">             auto &amp;refs = refs_it-&gt;second;</span><br><span class="line">             auto it = refs.find(key);</span><br><span class="line">             if (it != refs.end()) &#123;</span><br><span class="line">                 association.swap(it-&gt;second);</span><br><span class="line">                 refs.erase(it);</span><br><span class="line">                 if (refs.size() == 0) &#123;</span><br><span class="line">                     associations.erase(refs_it);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>try_emplace()</code> 方法特点是如果 container 中存在与参数相等的 key ，则直接返回，否则插入 pair 。因此如果返回值的 second 不为空即证明是第一次插入。如果要更新 value 的话，则需要手动 swap 一次。</p><p>如果 value 为 nil ，通过二次遍历找到 key 对应的 old value 后将其移除，如果在移除后该对象没有任何关联对象，则 associations 会将整个 <code>ObjcAssociation</code> 对象移除。</p><h3 id="Get-Associated-Object"><a href="#Get-Associated-Object" class="headerlink" title="Get Associated Object"></a>Get Associated Object</h3><p>Get 方法的实现相对简单，经过两层遍历去寻找关联对象，找不到会返回 nil ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">_object_get_associative_reference(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">&#123;</span><br><span class="line">    ObjcAssociation association&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap &amp;refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs.find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs.end()) &#123;</span><br><span class="line">                association = j-&gt;second;</span><br><span class="line">                association.retainReturnedValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> association.autoreleaseReturnedValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Remove-Assocations"><a href="#Remove-Assocations" class="headerlink" title="Remove Assocations"></a>Remove Assocations</h3><p>移除方法 <code>_object_remove_assocations(id object, bool deallocating)</code> 中可以看到有一个 <code>deallocating</code> 参数，这是因为 runtime 在销毁对象的 <code>objc_destructInstance</code> 方法中会主动调用移除该对象所有关联对象的方法，如果关联对象为系统对象 <code>SYSTEM_OBJECT</code> 则仅会在 deallocating 时销毁，主动调用时系统对象会被保留：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">_object_remove_assocations(id object, <span class="keyword">bool</span> deallocating)</span><br><span class="line">&#123;</span><br><span class="line">    ObjectAssociationMap refs&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">(manager.get())</span></span>;</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find((objc_object *)object);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            refs.swap(i-&gt;second);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If we are not deallocating, then SYSTEM_OBJECT associations are preserved.</span></span><br><span class="line">            <span class="keyword">bool</span> didReInsert = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!deallocating) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ref: refs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ref.second.policy() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123;</span><br><span class="line">                        i-&gt;second.insert(ref);</span><br><span class="line">                        didReInsert = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!didReInsert)</span><br><span class="line">                associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Associations to be released after the normal ones.</span></span><br><span class="line">    SmallVector&lt;ObjcAssociation *, <span class="number">4</span>&gt; laterRefs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release everything (outside of the lock).</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: refs) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i.second.policy() &amp; OBJC_ASSOCIATION_SYSTEM_OBJECT) &#123;</span><br><span class="line">            <span class="comment">// If we are not deallocating, then RELEASE_LATER associations don't get released.</span></span><br><span class="line">            <span class="keyword">if</span> (deallocating)</span><br><span class="line">                laterRefs.append(&amp;i.second);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i.second.releaseHeldValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> *later: laterRefs) &#123;</span><br><span class="line">        later-&gt;releaseHeldValue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上述分析看到 runtime 提供的关联对象本质上是通过全局的 hash map 对运行时传入的值与对象进行关联，并提供内存管理策略：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">OBJC_ENUM</span><span class="params">(<span class="keyword">uintptr_t</span>, objc_AssociationPolicy)</span> </span>&#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">    OBJC_ASSOCIATION_RETAIN = 01401,       /**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">    OBJC_ASSOCIATION_COPY = 01403          /**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br></pre></td></tr></table></figure></p><p>这些策略已经能符合大多数的需求，但如果我们想关联一个 weak 对象该如何做呢？上面提到对象与其关联对象拥有相同的生命周期，即对象的关联对象 map 会在析构时被释放，而 get 方法本质上是去查这个对象的 ObjcAssociation 表，这样自然做不到 weak reference 的特性。而 weak reference 也是 runtime 通过类似 Associated Object 的双层 Dense Map 结构实现的。</p><p>因此下面就来探讨一下如何实现一个 weak Associated Object 。</p><h2 id="Weak-Associated-Object"><a href="#Weak-Associated-Object" class="headerlink" title="Weak Associated Object"></a>Weak Associated Object</h2><p>其实思路比较简单，通过增加一个中间层的方式来实现。上面的源码看到，当拥有 Associated Object 的对象被析构，policy 为 RETAIN 的 Associated Object 会被发送 <code>objc_release</code> 消息。这样这个 Associated Object 的 weak reference 便可正常的置为 nil，具体如下 ：</p><p>一个 weak Associated Object 代理类，拥有一个 weak 修饰的属性<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WeakAssociatedObjectProxy</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>想要类的 category 中进行对象关联：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Weak</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) myObject &#123;</span><br><span class="line">    WeakAssociatedObjectProxy * proxy = objc_getAssociatedObject (<span class="keyword">self</span>,  <span class="keyword">@selector</span> (myObject));</span><br><span class="line">    <span class="keyword">return</span> proxy.object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) setMyObject:(<span class="built_in">NSString</span> *) myObject &#123;</span><br><span class="line">    WeakAssociatedObjectProxy *proxy = [[WeakAssociatedObjectProxy alloc]init];</span><br><span class="line">    proxy.object = myObject;</span><br><span class="line">    objc_setAssociatedObject (<span class="keyword">self</span>, <span class="keyword">@selector</span> (myObject), proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>用 RETAIN 关联的 proxy 对象在 self 被析构时会被发送 release 消息，进而会将其 weak 属性设为 nil 。</p><p>另一种方式可以通过 block 来作为中间层，通过 COPY 的 policy 让 block 持有传入的 myObject ，这种方式更加简洁：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSObject</span> (<span class="title">Weak</span>)</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) myObject &#123;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = objc_getAssociatedObject (<span class="keyword">self</span>, <span class="keyword">@selector</span> (myObject));</span><br><span class="line">    <span class="keyword">return</span> (block ? block () : <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) setMyObject:(<span class="built_in">NSString</span> *) myObject &#123;</span><br><span class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakObject = myObject;</span><br><span class="line">    <span class="keyword">id</span> (^block)(<span class="keyword">void</span>) = ^&#123; <span class="keyword">return</span> weakObject; &#125;;</span><br><span class="line">    objc_setAssociatedObject (<span class="keyword">self</span>, <span class="keyword">@selector</span> (myObject), block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Associated Objects 是 OC Runtime 2.0 中的特性之一，提供了为既有类动态添加关联对象的能力，也是对 category 只能拓展行为的一个很好的补充。它通过 Key-Value 的形式将对象与类绑定，并提供类似属性的关联策略，最终保存在全局的 
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>KingFisher 源码浅析</title>
    <link href="http://yoursite.com/2021/04/05/KingFisher_sourcecode/"/>
    <id>http://yoursite.com/2021/04/05/KingFisher_sourcecode/</id>
    <published>2021-04-04T16:00:00.000Z</published>
    <updated>2021-05-11T11:42:05.773Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/onevcat/Kingfisher" target="_blank" rel="noopener">Kingfisher</a>是一个纯 Swift 编写的图片加载库，支持图片的下载、缓存、处理（如分辨率、圆角、缩放）及设置时动画、占位图等等。充分利用了语言的特性实现丰富易用的 API ，良好的实践了 POP 的编程范式，且支持了最新的 SwiftUI。</p><h2 id="从一行调用开始"><a href="#从一行调用开始" class="headerlink" title="从一行调用开始"></a>从一行调用开始</h2><p>Kingfisher 的使用非常便捷：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://example.com/image.png"</span>)</span><br><span class="line">imageView.kf.setImage(with: url)</span><br></pre></td></tr></table></figure></p><p>当然也能处理更复杂的需求：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> processor = <span class="type">DownsamplingImageProcessor</span>(size: imageView.bounds.size)</span><br><span class="line">             |&gt; <span class="type">RoundCornerImageProcessor</span>(cornerRadius: <span class="number">20</span>)</span><br><span class="line">imageView.kf.indicatorType = .activity</span><br><span class="line">imageView.kf.setImage(</span><br><span class="line">    with: url,</span><br><span class="line">    placeholder: <span class="type">UIImage</span>(named: <span class="string">"placeholderImage"</span>),</span><br><span class="line">    options: [</span><br><span class="line">        .processor(processor),</span><br><span class="line">        .scaleFactor(<span class="type">UIScreen</span>.main.scale),</span><br><span class="line">        .transition(.fade(<span class="number">1</span>)),</span><br><span class="line">        .cacheOriginalImage</span><br><span class="line">    ])</span><br><span class="line">&#123;</span><br><span class="line">    result <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> .success(<span class="keyword">let</span> value):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Task done for: \(value.source.url?.absoluteString ?? "</span><span class="string">")"</span>)</span><br><span class="line">    <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Job failed: \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时也支持链式调用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">KF</span>.url(url)</span><br><span class="line">  .placeholder(placeholderImage)</span><br><span class="line">  .setProcessor(processor)</span><br><span class="line">  .loadDiskFileSynchronously()</span><br><span class="line">  .cacheMemoryOnly()</span><br><span class="line">  .fade(duration: <span class="number">0.25</span>)</span><br><span class="line">  .lowDataModeSource(.network(lowResolutionURL))</span><br><span class="line">  .onProgress &#123; receivedSize, totalSize <span class="keyword">in</span>  &#125;</span><br><span class="line">  .onSuccess &#123; result <span class="keyword">in</span>  &#125;</span><br><span class="line">  .onFailure &#123; error <span class="keyword">in</span> &#125;</span><br><span class="line">  .<span class="keyword">set</span>(to: imageView)</span><br></pre></td></tr></table></figure></p><p>Kingfisher 的 API 涉及兼顾了易用与实用性，并且有着非常详尽的注释。下面就从最常用的 <code>imageView.kf.setImage()</code> 方法来看看 KingFisher 的具体实现（以下简称 <strong>KF</strong>, 与构造器 <code>KF</code> 注意区分）。</p><h3 id="kf-setImage"><a href="#kf-setImage" class="headerlink" title=".kf.setImage()"></a>.kf.setImage()</h3><p>以 <code>ImageView</code> 为例，<strong>KF</strong> 通过协议 <code>KingfisherCompatible</code> 封装了一个名为 kf 的变量并在其<code>get</code>方法中通过向泛型传入<code>self</code>来方便对不同类型的拓展。忽略夸平台的代码后简化如下：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ImageView 实例变量 kf 的封装</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">KingfisherCompatible</span>: <span class="title">AnyObject</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KingfisherCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> kf: <span class="type">KingfisherWrapper</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">KingfisherWrapper</span>(<span class="keyword">self</span>) &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ImageView</span>: <span class="title">KingfisherCompatible</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>注意计算属性<code>kf</code>是一个<code>KingfisherWrapper</code>类型的结构体，这个结构体是对原生对象的封装，目的是为原生类拓展相应的自定义方法，通过泛型可以锁定原生类型，并通过 <code>base</code>实例对象持有该原生对象以供后续使用，取自 ImageView+KingFisher.swift 文件(忽略跨平台别名)：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KingfisherWrapper</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">ImageView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(）&#123;&#125;</span></span></span><br><span class="line"><span class="function"><span class="params">    ...</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure></p><p>以上便是 <strong>KF</strong> 利用协议和泛型对 ImageView 进行封装与能力的拓展，至此即可调用<code>imageView.kf.setImage()</code>了。</p><p>下面就通过<code>setImage()</code>方法的参数来分析下 <strong>KF</strong> 的一些功能封装与思想</p><h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setImage</span><span class="params">(with source: Source?)</span></span></span><br></pre></td></tr></table></figure><p><code>Source</code>是一个用来表示图片“来源”的枚举，一共两个 case ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"><span class="comment">// 图片来自网络或本地（取决于 url 格式）</span></span><br><span class="line"><span class="keyword">case</span> network(<span class="type">Resource</span>)</span><br><span class="line"><span class="comment">// 图片来自本地或其它编码格式</span></span><br><span class="line"><span class="keyword">case</span> provider(<span class="type">ImageDataProvider</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="network"><a href="#network" class="headerlink" title="network"></a>network</h3><p>先看<code>.network</code>，它的关联值是遵守<code>Resource</code>协议的对象，该协议的目的较简单，作用是通过<code>convertToSource</code>方法将一些通用资源转为 <code>Source</code>以方便进行 cache 和 download 。当然最常用的资源就是 url ：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URL</span>: <span class="title">Resource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheKey: <span class="type">String</span> &#123; <span class="keyword">return</span> absoluteString &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> downloadURL: <span class="type">URL</span> &#123; <span class="keyword">return</span> <span class="keyword">self</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然你也可以通过遵守<code>Resource</code>协议定义自己的资源类，只要提供缓存 key 和下载 url 即可交给 <strong>KF</strong> 处理。</p><h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p><code>Source</code>的另一个 case 是 provider ，它的关联值类型是<code>ImageDataProvider</code>。主要封装了本地图片的资源，该协议除了 cacheKey 和 fileURL 外，还要求提供一个处理图片 data 的方法供后续处理使用。<code>ImageDataProvider</code>同 <code>Resource</code>一样，提供了将资源转为<code>Source</code>的默认实现。</p><p>此外，<strong>KF</strong> 还提供了四个默认的 Provider ，分别为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于本地文件路径下的图片资源</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LocalFileImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于 Base64 编码的图片，需提供 Base64 字符串</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base64ImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于图片 data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RawImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br><span class="line"><span class="comment">// 用于处理 AVAsset 资源截图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AVAssetImageDataProvider</span>: <span class="title">ImageDataProvider</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>通过<code>Source</code>可以看到协议的优势，具有高拓展性、更好的抽象能力，另外也可以看到 Swift 中 Enum 的强大。</p><h2 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h2><p>Placeholder 的作用是在图片加载时或图片加载失败的情况下显示的默认图，<strong>KF</strong>通过协议<code>Placeholder</code>声明了两个方法并针对<code>UIView</code>和<code>UIImage</code>做了默认实现：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Placeholder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Placeholder</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span> &#123;</span><br><span class="line">        imageView.addSubview(<span class="keyword">self</span>)</span><br><span class="line">        translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        centerXAnchor.constraint(equalTo: imageView.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        centerYAnchor.constraint(equalTo: imageView.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        heightAnchor.constraint(equalTo: imageView.heightAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        widthAnchor.constraint(equalTo: imageView.widthAnchor).isActive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span> &#123;</span><br><span class="line">        removeFromSuperview()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过这个 extension 自定义的 View 也可以作为默认图被添加到 ImageView 上。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIImage</span>: <span class="title">Placeholder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(to imageView: KFCrossPlatformImageView)</span></span> &#123; imageView.image = <span class="keyword">self</span> &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(from imageView: KFCrossPlatformImageView)</span></span> &#123; imageView.image = <span class="literal">nil</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若默认图为<code>UIImage</code>则会被直接设置。</p><p>之后通过<code>KingfisherWrapper</code>封装的计算属性<code>placeholder</code>的<code>set/get</code>方法来调用其<code>add()</code>方法，并通过<code>setRetainedAssociatedObject()</code>来为 imageView 动态绑定属性。</p><blockquote><p><strong>Associated Objects</strong> 是 ObjC Runtime 提供的运行时绑定属性的能力，内部通过两层 Hash Map 来维护所有对象动态绑定的变量，但需注意同名覆盖问题  </p></blockquote><h2 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h2><p>Indicator 的作用是提示图片正在下载，同样是在<code>setImage()</code>方法内进行设置，通过<code>IndicatorType</code>提供了四种类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum IndicatorType &#123;</span><br><span class="line">    case none</span><br><span class="line">    case activity</span><br><span class="line">    case image(imageData: Data)</span><br><span class="line">    case custom(indicator: Indicator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但比较不解的是设置的方式，<strong>KF</strong> 并未在<code>setImage()</code>系列方法中提供相应参数，因此使用时需提前设置<code>imageView.kf.indicatorType = .activity</code>。</p><p>Indicator 的行为通过<code>Indicator</code>协议来抽象，并提供两种默认的实现，<code>ActivityIndicator</code>封装了系统的 progress view 和菊花两种样式，<code>ImageIndicator</code>封装的是图片样式，支持 Gif 格式。</p><h2 id="KingfisherOptionsInfo"><a href="#KingfisherOptionsInfo" class="headerlink" title="KingfisherOptionsInfo"></a>KingfisherOptionsInfo</h2><p><code>setImage()</code>之后的工作便是整合<code>options</code>这个参数，这个参数的类型是<code>[KingfisherOptionsInfoItem]</code>，<code>KingfisherOptionsInfoItem</code>是一个枚举，提供了丰富的配置项，涉及缓存、下载、图片处理、动画以及一些行为开关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">enum KingfisherOptionsInfoItem &#123;</span><br><span class="line">    case targetCache(ImageCache)</span><br><span class="line">    case originalCache(ImageCache)</span><br><span class="line">    case downloader(ImageDownloader)</span><br><span class="line">    case transition(ImageTransition)</span><br><span class="line">    case downloadPriority(Float)</span><br><span class="line">    case forceRefresh</span><br><span class="line">    case fromMemoryCacheOrRefresh</span><br><span class="line">    case forceTransition</span><br><span class="line">    case cacheMemoryOnly</span><br><span class="line">    case waitForCache</span><br><span class="line">    case onlyFromCache</span><br><span class="line">    case backgroundDecode</span><br><span class="line">    case callbackQueue(CallbackQueue)</span><br><span class="line">    case scaleFactor(CGFloat)</span><br><span class="line">    case preloadAllAnimationData</span><br><span class="line">    case requestModifier(AsyncImageDownloadRequestModifier)</span><br><span class="line">    case redirectHandler(ImageDownloadRedirectHandler)</span><br><span class="line">    case processor(ImageProcessor)</span><br><span class="line">    case cacheSerializer(CacheSerializer)</span><br><span class="line">    case imageModifier(ImageModifier)</span><br><span class="line">    case keepCurrentImageWhileLoading</span><br><span class="line">    case onlyLoadFirstFrame</span><br><span class="line">    case cacheOriginalImage</span><br><span class="line">    case onFailureImage(KFCrossPlatformImage?)</span><br><span class="line">    case alsoPrefetchToMemory</span><br><span class="line">    case loadDiskFileSynchronously</span><br><span class="line">    case memoryCacheExpiration(StorageExpiration)</span><br><span class="line">    case memoryCacheAccessExtendingExpiration(ExpirationExtending)</span><br><span class="line">    case diskCacheExpiration(StorageExpiration)</span><br><span class="line">    case diskCacheAccessExtendingExpiration(ExpirationExtending)</span><br><span class="line">    case processingQueue(CallbackQueue)</span><br><span class="line">    case progressiveJPEG(ImageProgressive)</span><br><span class="line">    case alternativeSources([Source])</span><br><span class="line">    case retryStrategy(RetryStrategy)</span><br><span class="line">    case lowDataMode(Source?)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之后<strong>KF</strong>将<code>options</code>连同<code>source</code>、<code>completion</code>等作为参数传至<br><code>KingfisherManager.shared.retrieveImage()</code>方法并返回一个 task 。至此我们通过<code>setImage()</code>方法见到了 <strong>KF</strong> 核心功能的调度者<code>KingfisherManager</code>，它的工作包括下载、存取（缓存）、处理。下面通过<code>KingfisherManager</code>来具体看下这些核心功能的实现。</p><hr><h2 id="KingfisherManager"><a href="#KingfisherManager" class="headerlink" title="KingfisherManager"></a>KingfisherManager</h2><p>这个类的核心是名为<code>retrieveImage()</code>的系列方法，除了供外部调用的两个方法，还包括内部对参数的处理，以及对重试、成功及失败的各种 handle ，这里不具体展开了，着重看下最终的调用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">retrieveImage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        with source: Source,</span></span></span><br><span class="line"><span class="function"><span class="params">        context: RetrievingContext,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: <span class="params">(<span class="params">(Result&lt;RetrieveImageResult, KingfisherError&gt;)</span></span></span></span> -&gt; <span class="type">Void</span>)?) -&gt; <span class="type">DownloadTask?</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> options = context.options</span><br><span class="line">        <span class="keyword">if</span> options.forceRefresh &#123;</span><br><span class="line">            <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)?.value</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> loadedFromCache = retrieveImageFromCache(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> loadedFromCache &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> options.onlyFromCache &#123;</span><br><span class="line">                <span class="keyword">let</span> error = <span class="type">KingfisherError</span>.cacheError(reason: .imageNotExisting(key: source.cacheKey))</span><br><span class="line">                completionHandler?(.failure(error))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> loadAndCacheImage(</span><br><span class="line">                source: source,</span><br><span class="line">                context: context,</span><br><span class="line">                completionHandler: completionHandler)?.value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中的调用的两个方法<code>loadAndCacheImage()</code>和<code>retrieveImageFromCache()</code>分别负责加载并缓存图片以及从缓存中读取。通过之前传入的<code>options</code>来判断。</p><h3 id="Download"><a href="#Download" class="headerlink" title="Download"></a>Download</h3><p><strong>KF</strong> 通过<code>ImageDownloader</code>类用来管理图片的下载，提供相应的接口，下载任务是由封装了<code>URLSessionDataTask</code>的<code>SessionDataTask</code>实现，并对并发任务做了优化。另外需要注意的是<code>SessionDelegate</code>这个类，除了作为<code>URLSessionDataDelegate</code>的 handler ，也承担了下载任务的维护。</p><p><code>ImageDownloader</code> 是对外暴露的图片下载管理类，提供图片下载和取消的接口。接受<code>SessionDelegate</code>的回调，并通过<code>ImageDownloaderDelegate</code>来供外部处理下载结果及在处理下载周期中各时间点的时机。</p><p>此外在 downloadImage 方法的<code>option</code>参数中提供了一个<code>requestModifier</code>，在 request 发出之前支持对其进行修改，如添加 header 、map URL 等，体现了良好的开放性。</p><p>前面提到<code>SessionDataTask</code>是对<code>URLSessionDataTask</code>的封装，其内部声明了一个结构体<code>TaskCallback</code>，保存 downloadImage 方法中传入的回调以及 options ，用于后续下载流程使用。其中比较重要的是在图片下载完成后，通过<code>ImageDataProcessor</code>来将下载下来的 data 处理为图片，处理时会从<code>TaskCallback</code>对象中的 option 取出 <code>ImageProcessor</code>对象并调用其<code>process</code>方法，处理完成后通过 callback 返回结果。如果你不想对图片进行额外处理，<strong>KF</strong> 默认提供了<code>DefaultImageProcessor</code>。</p><p>从这个简单的 downloadImage 系列方法可以看到 SDK 设计的重要原则，为调用者提供充分的拓展性，同时在内部约束这些开放的行为，良好的实践了开闭原则。其它的一些细节包括封装了一个<code>Delegate</code>类来帮助管理 closure 中对<code>self</code>的弱引用（感觉作用不大），一个名为<code>CallbackQueue</code>的枚举来方便任务派发的线程等。</p><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><strong>KF</strong> 提供的缓存同时支持内存缓存与磁盘缓存，可分别设置缓存过期时间及占用大小，同时维护了 IO 线程以保证读写安全。在 init 方法中分别初始化内存与磁盘缓存类，内存缓存的默认大小是设备物理内存大小的 1/4 ，接着初始化线程，注册通知：收到<code>didReceiveMemoryWarningNotification</code>时去清理内存缓存，收到<code>willTerminateNotification</code>和<code>didEnterBackgroundNotification</code>时清理磁盘空间。</p><p>存储图片时会首先将图片存入内存缓存，如果<code>toDisk</code>参数为 true ，则在 IO 线程中将图片写入磁盘，删除图片时也会同时检查内存缓存与磁盘缓存。</p><p>从缓存中取图片的流程是首先检查内存缓存，查到后直接返回，否则去查磁盘缓存，若查到则先将图片写入内存，写入完成后再将图片通过回调返回。<strong>KF</strong>也提供了直接从内存或磁盘取图片的接口。</p><p>清空缓存没有什么特别，同样提供的统一清理和分别清理内存和磁盘缓存的接口，已经后台清理磁盘缓存的功能。</p><p>此外还包括查询图片是否已被缓存、缓存的类型、缓存的 key 对应的文件名，以及查询已用的磁盘缓存空间等。下面来看下内存缓存与磁盘缓存的具体实现。</p><h4 id="Memory-cache"><a href="#Memory-cache" class="headerlink" title="Memory cache"></a>Memory cache</h4><p>首先不太理解的是<strong>KF</strong>的<code>MemoryStorage</code>本身是个遵守<code>Storage</code>协议的类。但后面被改为了 enum ，仅作用为一个命名空间，内部封装的<code>Backend</code>才是真正实现缓存逻辑的类。此外还封装了<code>Congfig</code>以及<code>StorageObject</code>。</p><p><code>Backend</code>是一个泛型类，即只保存该泛型的数据，同时<code>CacheCostCalculable</code>要求提供一个<code>cacheCost</code>变量：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Backend</span>&lt;<span class="title">T</span>: <span class="title">CacheCostCalculable</span>&gt; </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">KFCrossPlatformImage</span>: <span class="title">CacheCostCalculable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Cost of an image</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> cacheCost: <span class="type">Int</span> &#123; <span class="keyword">return</span> kf.cost &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其内部持有了一个<code>NSCache</code>对象，key 为<code>String</code>，value 为<code>StorageObject</code>。所以<strong>KF</strong>的内存缓存就是通过<code>NSCache</code>实现的，虽然<code>NSCache</code>是号称线程安全，但<strong>KF</strong>还是给读写操作加了锁。</p><p>此外在内存的清理上，<strong>KF</strong>起了一个 timer 来定时清理过期的缓存对象，默认间隔为 2 分钟，过期时间默认为 5 分钟。而且提到的<code>ImageCache</code>类在接受到<code>didReceiveMemoryWarningNotification</code>时会直接将内存缓存清空。</p><h4 id="Disk-cache"><a href="#Disk-cache" class="headerlink" title="Disk cache"></a>Disk cache</h4><p>磁盘缓存是通过<code>FileManager</code>进行数据读写的，但<strong>KF</strong>额外的做了几件事。</p><p>同<code>MemoryStorage</code>一样，<code>DiskStorage</code>也是一个没有 case 的枚举，内部同样声明了一个泛型类<code>Backend</code>来实现缓存的主要逻辑，但泛型约束协议与<code>MemoryStorage</code>不同：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataTransformable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toData</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromData</span><span class="params">(<span class="number">_</span> data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Self</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> empty: <span class="type">Self</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该协议要求实现 Data 与 Self 的相互转换，并提供一个空数据的实现。主要用于从 File system 存取数据时的类型转换。</p><p>为了提高查找效率，<strong>KF</strong>维护了一个<code>Set</code>用来保存已存入缓存的文件名，在查找文件时优先检查该 set 中是否有对应文件名，如果没有直接返回 nil 已减少对 File system 的访问次数。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从一行调用开始，分析了<strong>KF</strong>提供的各种特性及实现，并重点关注了下载和缓存的实现，当然还有很多细节没有覆盖到，比如图片的绘制（圆角、裁切、效果）、图片格式的处理等等。</p><p><strong>KF</strong>充分的利用了 Swift 语言的特性，在 API 的设计上非常实用且规范，同时保留了足够的可拓展性，在具体实现层面，<strong>KF</strong>并没有采用特别复杂的技术方案，但功能完善且实用性强，是一个值得学习的开源项目。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/onevcat/Kingfisher&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kingfisher&lt;/a&gt;是一个纯 Swift 编写的图片加载库，支持图片的下载、缓存、处理（如分辨率、圆角、缩放
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 启动速度优化</title>
    <link href="http://yoursite.com/2021/03/01/ios_launch_optimize/"/>
    <id>http://yoursite.com/2021/03/01/ios_launch_optimize/</id>
    <published>2021-02-28T16:00:00.000Z</published>
    <updated>2021-03-02T08:55:50.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>在做优化前应将应用当前的耗时情况进行完善的统计，以便后续通过数据发现问题，以及对比优化效果。</p><p>我们的统计工作分位两个维度，一个是启动耗时的分段耗时及总耗时的统计，另一个是针对具体的启动项或函数的耗时进行统计及上报。</p><h3 id="启动耗时统计"><a href="#启动耗时统计" class="headerlink" title="启动耗时统计"></a>启动耗时统计</h3><p>我们将启动耗时分成两个阶段，第一阶段从系统创建 APP 进程（用户点击图标）到 <code>main</code> 函数开始执行，即 <strong>pre-main</strong> 阶段。第二阶段即从  <code>didFinishLaunching</code> 开始执行到首页渲染完毕。</p><p>至于 <code>main</code> 函数到 <code>didFinishLaunching</code> 开始这段耗时根据我们的统计占用耗时较少（约为几十毫秒）且浮动不大，因此将第二阶段的起点放在 <code>didFinishLaunching</code> 的开始，但在统计总体耗时的时候还是会将其包括在内。</p><h4 id="Pre-main-耗时统计"><a href="#Pre-main-耗时统计" class="headerlink" title="Pre-main 耗时统计"></a>Pre-main 耗时统计</h4><p>在调试时可以通过增加 <code>DYLD_PRINT_STATISTICS</code> 和 <code>DYLD_PRINT_STATISTICS_DETAILS</code> 来打印出 <strong>dyld</strong> 的启动耗时，包括了各阶段的耗时及链接的动态库列表，但该耗时不包括加载 <strong>dyld</strong> 及之前的耗时。可以作为优化时的参考。</p><p>对于数据的上报，我们通过在 <code>main</code> 函数执行时通过 <code>sysctl</code> 函数去拿到进程创建的时间，具体如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)processInfoForPID:(<span class="keyword">int</span>)pid procInfo:(<span class="keyword">struct</span> kinfo_proc*)procInfo &#123;</span><br><span class="line">    <span class="keyword">int</span> cmd[<span class="number">4</span>] = &#123;<span class="built_in">CTL_KERN</span>, KERN_PROC, KERN_PROC_PID, pid&#125;;</span><br><span class="line">    size_t size = <span class="keyword">sizeof</span>(*procInfo);</span><br><span class="line">    <span class="keyword">return</span> sysctl(cmd, <span class="keyword">sizeof</span>(cmd)/<span class="keyword">sizeof</span>(*cmd), procInfo, &amp;size, <span class="literal">NULL</span>, <span class="number">0</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimeInterval</span>)processStartTime &#123;</span><br><span class="line">    <span class="keyword">struct</span> kinfo_proc kProcInfo;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> processInfoForPID:[[<span class="built_in">NSProcessInfo</span> processInfo] processIdentifier] procInfo:&amp;kProcInfo]) &#123;</span><br><span class="line">        <span class="keyword">return</span> kProcInfo.kp_proc.p_un.__p_starttime.tv_sec * <span class="number">1000.0</span> + kProcInfo.kp_proc.p_un.__p_starttime.tv_usec / <span class="number">1000.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后以 <code>main</code> 函数开始执行作为 <strong>Pre-main</strong> 阶段的终点进行数据上报。</p><h4 id="After-main-耗时统计"><a href="#After-main-耗时统计" class="headerlink" title="After-main 耗时统计"></a>After-main 耗时统计</h4><p>以 <code>didFinishLaunching</code> 开始执行为起点，到首页渲染完成为终点。这里的终点会有几种打点方式，之前我们以首页的 <code>viewDidAppear</code> 首次调用作为首页渲染完成的标志，并在优化过程中将非必要启动项置于该方法的回调之后。但经过几个版本的数据分析（项目接入的 APM 监控）发现这块耗时会有较多的极端数据出现，且难以排查到具体原因和复现，因此我们决定修改该阶段终点的打点时机。</p><p>Apple 的 APM 统计 <strong>Metrics</strong> 框架将启动耗时的终点定在第一次 <code>CA::Transaction::commit</code>。而抖音的方案是根据 iOS 的版本，iOS 12 及以下使用 <code>viewDidAppear</code>，否则以 <code>applicationDidBecomeActive</code> 作为终点。</p><p>最终我们决定使用 <strong>Metrics</strong> 的做法，去监听 first <code>CA::Transaction::commit</code>，方式是通过 <strong>Runloop</strong> 来监听：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop]getCFRunLoop];</span><br><span class="line">if (@available(iOS 13.0, *)) &#123;</span><br><span class="line">    CFRunLoopActivity activities = kCFRunLoopAllActivities;</span><br><span class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, activities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</span><br><span class="line">        if (activity == kCFRunLoopBeforeTimers) &#123;</span><br><span class="line">            // 打点记录</span><br><span class="line">            CFRunLoopRemoveObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    CFRunLoopAddObserver(mainRunloop, observer, kCFRunLoopCommonModes);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    CFRunLoopPerformBlock(mainRunloop, NSDefaultRunLoopMode, ^&#123;</span><br><span class="line">        // 打点记录</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>系统对于界面更新的处理方式是当 <code>UIView/CALayer</code> 发生属性变动、层级变动或设置了 <code>setNeedsLayout/setNeedsDisplay</code> 时，该 <code>UIView/CALayer</code> 会被标记为待处理并被提交到一个全局容器中。然后在通过 Runloop 中监听 <code>kCFRunLoopBeforeWaiting</code> 和 <code>kCFRunLoopExit</code> 两个事件，来处理被标记的视图变化，具体是调用了 <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code> 这个方法，其内部调用栈大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure></p><p>具体可参考 YY 关于 Runloop 的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">这篇文章</a>。</p><p>因此通过监听 Runloop 的事件可以拿到与第一次 <code>CA::Transaction::commit()</code> 非常接近的时间点。但经过实际测试发现，不同系统的回调时机会有较大的差异，不能简单的监听 Runloop 的第一次 <code>beforeWaiting</code>。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// iOS 13.1.3</span><br><span class="line">kCFRunLoopBeforeTimers: 1088171.925382</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.049286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.062607</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.081497</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.094928</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.095982</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096286</span><br><span class="line">kCFRunLoopBeforeTimers: 1088172.096508</span><br><span class="line">kCFRunLoopBeforeWaiting: 1088172.096728</span><br><span class="line">First View Did Appear: 1088172.154152</span><br><span class="line"></span><br><span class="line">// iOS 14.3</span><br><span class="line">First View Did Appear: 13255.515243</span><br><span class="line">kCFRunLoopBeforeTimers: 13255.545548</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.364940</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.365692</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.380215</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381132</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381725</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381765</span><br><span class="line">kCFRunLoopBeforeTimers: 13257.381807</span><br><span class="line">kCFRunLoopBeforeWaiting: 13257.381919</span><br></pre></td></tr></table></figure></p><p>可以看到在 iOS 13 上的表现基本符合预期，在提交了 Transaction 后的某个时间点首页渲染完成并调起了 <code>viewDidAppear</code> ，但在 iOS 14 上，Runloop 的回调会晚于 <code>viewDidAppear</code> 。</p><p>因此在该阶段终点即整个启动阶段的终点的打点时机上，如果想要监听 first <code>CA::Transaction::commit()</code>，需要对系统进行区分以获取最合理的时机，或者采用 first <code>viewDidAppear</code>加 first <code>applicationDidBecomeActive</code>的方式也是可以的。</p><h2 id="分阶段优化"><a href="#分阶段优化" class="headerlink" title="分阶段优化"></a>分阶段优化</h2><h3 id="Pre-main-阶段"><a href="#Pre-main-阶段" class="headerlink" title="Pre-main 阶段"></a>Pre-main 阶段</h3><p>通过 <code>DYLD_PRINT_STATISTICS</code> 可以比较清楚的看到该阶段内做了哪些事情以及它们的耗时情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Total pre-main time: 948.13 milliseconds (100.0%)</span><br><span class="line">         dylib loading time: 145.53 milliseconds (15.3%)</span><br><span class="line">        rebase/binding time: 113.82 milliseconds (12.0%)</span><br><span class="line">            ObjC setup time: 165.37 milliseconds (17.4%)</span><br><span class="line">           initializer time: 523.40 milliseconds (55.2%)</span><br><span class="line">           slowest intializers :</span><br><span class="line">             libSystem.B.dylib :   5.35 milliseconds (0.5%)</span><br><span class="line">    libMainThreadChecker.dylib :  25.31 milliseconds (2.6%)</span><br><span class="line">          libglInterpose.dylib : 213.90 milliseconds (22.5%)</span><br><span class="line">              MyApp : 465.52 milliseconds (49.0%)</span><br></pre></td></tr></table></figure></p><p>其实在 dylib loading 开始前，系统会创建进程并为其开辟内存空间，然后加载可执行文件。之后加载 dyld（本身也是动态库），创建启动闭包（dyld3 ，更新 App 或重启手机后），完成后 dyld 开始分析动态库依赖，并逐一加载，即 <code>dylib loading time</code> 开始。加载完成后需对动态库进行符号绑定，即 <code>rebase/binding time</code>。因此动态库的数量是影响这段耗时的主要因素，包括系统库，而我们的项目已经全部采用静态库的方式。不但减少启动耗时，也可减少包体积。</p><p>之后的 <code>ObjC setup time</code> 的主要工作是 <code>Class</code> 注册、<code>Category</code> 注册（向类中插入方法）及方法唯一性检查等。这一段的优化工作主要在无用类及 <code>Category</code> 的检查上，之前常规的方案是通过 Mach-O 文件分析，取 <code>classlist</code> 与 <code>classref</code> 的差集，但这里推荐一个准确性更高的工具：<a href="https://github.com/wuba/WBBlades" target="_blank" rel="noopener">WBBlades</a>，通过分析 Mach-O 文件，解决了类的动态调用、类的继承关系和类内调用等问题。</p><p><code>initializer time</code> 中主要是 <code>+load()</code> 方法调用、<strong>c++</strong> 构造函数和静态全局变量的创建。而 <code>+load()</code> 方法除了本身的耗时，还会触发 Page in 读入物理内存以执行该函数。从上面的 log 可以看到这段耗时占到整个 Pre-main 耗时的一半以上，因此针对 <code>+load()</code> 方法的优化就是尽可能不用该方法，改为 <code>+initialize()</code>等懒加载的方式。对于 <strong>c++</strong> 的静态初始化，可将 <code>static</code> 变量迁移至方法内部以改为懒加载的方式，借鉴<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487757&amp;idx=1&amp;sn=a52c11f6a6f217bd0d3283de9b00c8bc&amp;chksm=e9d0daefdea753f954cfcb15d5d0f90302a9f45ba06968377644ffe9e5757a69c5b0132d2c8b&amp;mpshare=1&amp;scene=1&amp;srcid=0125oJOAovQbQckW9TdR8cTn&amp;sharer_sharetime=1611540323121&amp;sharer_shareid=4e61187060391b97449b816517d4ddd7&amp;version=3.0.31.6162&amp;platform=mac#rd" target="_blank" rel="noopener">这篇</a>的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Good</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">GetBucketThing</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> bucket[] = &#123;<span class="string">"apples"</span>, <span class="string">"pears"</span>, <span class="string">"meerkats"</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> bucket[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="After-main-阶段"><a href="#After-main-阶段" class="headerlink" title="After-main 阶段"></a>After-main 阶段</h3><p>该阶段的优化重点是启动项、首页的初始化及生命周期方法。</p><h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><p>启动项的治理思路比较简单，将非必要的启动项通过置后、异步或懒加载等方式来减少耗时。</p><p>另外，可以针对启动项进行统一管理，如耗时统计，包括线下 log 及线上监控，在我们的优化过程中发现仅以本地 log 作为依据是无法完全覆盖所有的启动场景的，在上线了线上监控后发现某些启动项耗时会有很大的波动，出现较高的耗时。在了解启动项耗时的基本情况后，再对高耗时的启动项进行摸排，找到具体耗时原因进行优化。</p><p>启动项统一管理的作用还包括解决启动依赖、控制并发、更好的管控新增的启动项等。</p><h4 id="首页耗时"><a href="#首页耗时" class="headerlink" title="首页耗时"></a>首页耗时</h4><p>这一阶段的主要工作包括首页及相关页面对子视图的加载渲染、网络请求、数据同步、各配置项的同步及组件的初始化等等。对于这段耗时的监控我们借助了 Instrument 的 Time Profiler 以及本地打点的方式。其中 Time Profiler 使用的时定期抓取主线程堆栈的方式，间隔为 1ms ，通过对线程快照的对比来进行耗时统计。如果觉得 Time Profiler 粒度太粗也可以自行设置间隔来抓取主线程的堆栈，如通过 <code>Thread.callStackSymbols</code> 或 <code>__builtin_frame_address</code>取到当前栈帧的地址，通过 <code>dladdr(UnsafeRawPointer(bitPattern: address), &amp;i)</code> 得到该栈帧的 <code>dl_info</code>，该结构体如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public struct dl_info &#123;</span><br><span class="line">public var dli_fname: UnsafePointer&lt;Int8&gt;! //* Pathname of shared object *//</span><br><span class="line">public var dli_fbase: UnsafeMutableRawPointer! //* Base address of shared object *//</span><br><span class="line">    public var dli_sname: UnsafePointer&lt;Int8&gt;! //* Name of nearest symbol *//</span><br><span class="line">    public var dli_saddr: UnsafeMutableRawPointer! //* Address of nearest symbol *//</span><br><span class="line">    public init()</span><br><span class="line">    public init(dli_fname: UnsafePointer&lt;Int8&gt;!, dli_fbase: UnsafeMutableRawPointer!, dli_sname: UnsafePointer&lt;Int8&gt;!, dli_saddr: UnsafeMutableRawPointer!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>dli_sname</code>即为符号名。最后通过 <code>Frame Pointer</code> 的偏移来遍历整个调用栈的符号。</p><p>另一种思路是直接对方法进行打点，比较容易想到的是 hook <code>objc_msgsend</code>，但弊端是静态函数记录不到，如纯 Swift 方法。也可在编译期通过对代码进行插桩实现打点，如利用 Clang 提供的代码覆盖工具 <a href="https://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs" target="_blank" rel="noopener">SanitizerCoverage</a>，可覆盖 OC/Swift/C/C++ 等语言。</p><p>具体的耗时情况及解决办法也是因项目而异的，比较通用的耗时点比如子视图的加载，在我们的项目中使用了 <code>MJRefreshGifHeader</code> , 并在其初始化时从 bundle 中分别取了 15 至 20 张图片传至 GifHeader 中不同的状态，造成了大量的耗时。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h3><blockquote><p>页缺失（英语：Page fault，又名硬错误、硬中断、分页错误、寻页缺失、缺页中断、页故障等）指的是当软件试图访问已映射在虚拟地址空间中，但是目前并未被加载在物理内存中的一个分页时，由中央处理器的内存管理单元所发出的中断。通常情况下，用于处理此中断的程序是操作系统的一部分。如果操作系统判断此次访问是有效的，那么操作系统会尝试将相关的分页从硬盘上的虚拟内存文件中调入内存。  </p></blockquote><p>每触发 Page fault 都会有一定的耗时（一次约 0.6~0.8 ms），当触发量足够多时其耗时也是比较可观的。具体消耗可通过 <strong>Instruments</strong> 的 System Trace 查看，注意这个消耗不是恒定的，受系统内存使用情况的影响，因此在测试前可重启手机，或打开多个 App 来尽量占用系统内存。</p><p>Xcode 在 Build Settings - Linking - Order File 中提供了一个设置 Order file 的路径。该文件是一个<code>.order</code>后缀的文本文件，链接器会根据该文件改变其中符号在内存中的布局，且会置于对应 section 的开始，对于不存在的符号会选择忽略。</p><p>通过将启动过程中所使用的函数符号通过 order file 告知链接器进行重排，将它们尽量排在相邻靠前的内存页中，从而减少 Page fault 触发次数，进而减少启动耗时。</p><p>因此重排的终点就是生成覆盖面尽量全的 order file。</p><p>我们采用的方式是 Clang 提供的 SanitizerCoverage，也就是编译期插桩的方式。该方案的优势在于覆盖面广（OC/Swift/C++，method/function/block），侵入性小，开发成本少（有很多现成的方案可借鉴，实现都大同小异）。将启动到首页显示期间运行的函数符号记录在 order file 中，然后放入项目路径下，可通过 LinkMap 来对比使用前后的符号排列是否变化。</p><p>至于具体的优化效果，本地测试下来成效不是很明显。而且本身对二进制重排并没有抱多少期望，只是在做完基础优化工作后的额外尝试，效果有点算点吧~</p><h3 id="TEXT-段重命名"><a href="#TEXT-段重命名" class="headerlink" title="__TEXT 段重命名"></a>__TEXT 段重命名</h3><p>因为 App Store Connect 会对我们上传 Mach-O 的 Text 段进行加密，以防止代码的泄露。而在启动过程会触发大量的 Page in 动作，其中包括将 Text 段的页读入物理内存，这就需要先对其解密，从而产生耗时以及 Text 段的体积变大。（此过程已在 iOS 13 被优化，Page in 不需要再解密了）</p><p>如果你的应用仍支持 iOS 13 以下的版本，比如我们还在 iOS 9 😓 。可以尝试一下段重命名的方案。链接器 ld 的 <code>-rename-section</code> 命令可以将 Text 段的内容移至其它的段，从而规避解密的耗时。具体可看<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247487459&amp;idx=1&amp;sn=3dd9276f5af78ca5a377adec37e3e916&amp;chksm=e9d0c401dea74d17e9f1bdd5ea764cc0cd7e845c6ebadde752d36608306b09e762a1681c7252&amp;scene=178&amp;cur_album_id=1665528287604817930#rd" target="_blank" rel="noopener">这篇</a>，跟重排一样，不用抱太大希望，不过对包大小的优化效果还是有的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据统计&quot;&gt;&lt;a href=&quot;#数据统计&quot; class=&quot;headerlink&quot; title=&quot;数据统计&quot;&gt;&lt;/a&gt;数据统计&lt;/h2&gt;&lt;p&gt;在做优化前应将应用当前的耗时情况进行完善的统计，以便后续通过数据发现问题，以及对比优化效果。&lt;/p&gt;
&lt;p&gt;我们的统计工作分
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第八周</title>
    <link href="http://yoursite.com/2020/08/09/ATRS_week_8/"/>
    <id>http://yoursite.com/2020/08/09/ATRS_week_8/</id>
    <published>2020-08-08T16:00:00.000Z</published>
    <updated>2020-08-09T06:20:56.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">Leetcode 13： 罗马数字转整数</a> </p><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>例如， 罗马数字 2 写做<code>II</code>，即为两个并列的 1。12 写做<code>XII</code>，即为<code>X</code>+<code>II</code>。 27 写做<code>XXVII</code>, 即为<code>XX</code>+<code>V</code>+<code>II</code>。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做<code>IIII</code>，而是<code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为<code>IX</code>。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用双指针遍历，比较当前数与前一位数的大小，若小为减， 大为加。</p><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">romanToInt</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> !s.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> start = s.startIndex</span><br><span class="line">    <span class="keyword">var</span> preNum = valueFrom(s[start])</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ..&lt; s.<span class="built_in">count</span> &#123;</span><br><span class="line">        num = valueFrom(s[s.index(start, offsetBy: i)])</span><br><span class="line">        <span class="keyword">if</span> preNum &lt; num &#123;</span><br><span class="line">            res -= preNum</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += preNum</span><br><span class="line">        &#125;</span><br><span class="line">        preNum = num</span><br><span class="line">    &#125;</span><br><span class="line">    res += preNum</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">valueFrom</span><span class="params">(<span class="number">_</span> str: Character)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> str &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"I"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"V"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"X"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"L"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">50</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"C"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"D"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"M"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1000</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://oleb.net/2020/as/" target="_blank" rel="noopener">as, as?, and as!</a></p><p>一篇来自 Ole Begemann 的文章，讨论了 Swift 中 <code>as</code>、<code>as?</code>和<code>as!</code> 的区别：</p><p><code>as！</code>和<code>as?</code>是运行时操作，而<code>as</code>是在编译期对类型进行转换。这也能够解释为何 <code>4 as Double</code>可以编译运行而<code>4 as! Double</code>会 crash，因为前者表达式中的 4 是 <strong>integer literal</strong> ，还没有具体类型，而后者表达式中的 4 已经是 Int 类型，而 Swift 中不允许数字类型间的隐式转换，导致了 crash 。</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>在上文的算法中需要用到<code>String</code>的<code>index</code>，其特点有：</p><ul><li>需要用<code>String</code>实例方法来生成<code>String.Index</code>实例</li><li>使用的方法是<code>startIndex</code> + <code>offset</code>的方式，如：</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aString = <span class="string">"im a string"</span></span><br><span class="line"><span class="keyword">let</span> index = aString.index(aString.startIndex, offsetBy: <span class="number">3</span>)</span><br><span class="line"><span class="keyword">let</span> char = aString[index] <span class="comment">// Character</span></span><br></pre></td></tr></table></figure><p>这样设计的原因，首先是因为<code>String</code>的元素是<strong>不等长</strong>的，每个元素可能是由 1~4 个<code>UTF8</code>码位组成，这意味着无法通过数组的那种简单的<code>起始地址 + index * 元素长度</code>的方式取到对应元素，若简单实用 <code>Int</code>作为下标会使遍历的时间复杂度会比等长数组高一个数量级。</p><p>因此<code>String</code>通过<code>Index</code>来解决这个问题，内部记录对应元素的偏移量来复用查找下一个元素。</p><p>String.Index 的内存布局：</p><ul><li>position aka <code>encodedOffset</code>: 一个 48 bit 值，用来记录码位偏移量</li><li>transcoded offset: 一个 2 bit 的值，用来记录字符使用的码位数量</li><li>grapheme cache: 一个 6 bit 的值，用来记录下一个字符的边界 </li><li>reserved: 7 bit 的预留字段</li><li>scalar aligned: 一个 1 bit 的值，用来记录标量是否已经对齐过</li></ul><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://rollout.io/blog/swift-method-swizzling/" target="_blank" rel="noopener">Rollout Swift Support – Under The Hood</a></p><p>Rollout 利用 SIL 来实现的 Swift 代码热修复，通过拦截 swiftc 编译出的文件，识别其中所有的方法并在方法之上封装一层，使方法可以执行一个从 Rollout 云下载的 JS 函数，当然也可以调用原函数，从而实现热修复的能力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第七周</title>
    <link href="http://yoursite.com/2020/07/19/ARTS_week_7/"/>
    <id>http://yoursite.com/2020/07/19/ARTS_week_7/</id>
    <published>2020-07-18T16:00:00.000Z</published>
    <updated>2020-07-19T13:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">LeetCode 9: 回文数</a></p><blockquote><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。  </p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>采用反转一半数字的思路，需要注意的是何时可以判断我们已经反转了一半数字：若为回文数，则反转数不断增加，原数不断减少，当两者相等（偶数）或反转数大于原数时（奇数），即为一半。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isPalindrome</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> tmpX = x</span><br><span class="line">        <span class="keyword">var</span> reverted = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> (tmpX &gt; reverted) &#123;</span><br><span class="line">            reverted = reverted * <span class="number">10</span> + tmpX % <span class="number">10</span></span><br><span class="line">            tmpX /= <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmpX == reverted/<span class="number">10</span> || tmpX == reverted</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://developer.apple.com/videos/play/wwdc2020/10163/" target="_blank" rel="noopener">Advancements in the Objective-C runtime</a></p><p>这个 session 来自 <strong>WWDC2020</strong> ，介绍了苹果对 OC Runtime 的一些优化。</p><h4 id="调整类的结构"><a href="#调整类的结构" class="headerlink" title="调整类的结构"></a>调整类的结构</h4><p>以往的类结构中，将只读的类信息结构体（编译器创建）存入 clean memory，以节约内存，而可读写的类信息结构体（运行时创建）存入 dirty memory ，由于不能 page out 而更为昂贵。本次的优化思路是将原来的可读写类信息结构体<code>class_rw_t</code>拆分为<code>class_rw_t</code>+<code>class_rw_ext_t</code>，后者即为该结构体中的动态部分，必须存入 dirty memory ，而剩下的<code>class_rw_t</code>则可以放入 clean memory。</p><p>经过优化后的类可达到 90% 的 clean memory ，系统层面节约 14 MB 内存。</p><blockquote><p><code>head xxxxx | egrep ‘class_rw|COUNT’</code>可查看应用<code>class_rw_t</code>消耗的内存，xxxx 为应用名。  </p></blockquote><h4 id="相对方法地址"><a href="#相对方法地址" class="headerlink" title="相对方法地址"></a>相对方法地址</h4><p>在类的结构体中包含一个<strong>方法列表</strong>，每个方法包含三个部分：selector/方法类型编码/IMP 指针，在 64 位的系统中，每个部分占用 8 个字节。</p><p>在 APP 的进程内存空间中，包括了各种链接库，这些库在链接过程中会将地址偏移以确定最终的地址，但由于方法实现地址不会脱离当前库的地址范围，方法列表并不需要 64 位的寻址空间，只需要在自己的库地址中查找引用函数地址，因此可以使用 32 位<strong>相对</strong>偏移来代替<strong>绝对</strong> 64 位地址。</p><p>这样做的优点有：</p><ol><li>库被加载后不需要修正指针地址，因为偏移量是相同的</li><li>方法可被保存到只读存储器中，这会更加安全</li><li>使用 32 位+偏移量在 64 位平台上节约了一半内存</li></ol><blockquote><p>而针对 Method Swizzling 的情况，需要额外维护一个映射表以保存方法实现的地址。因此相较于优化前，Method Swizzling 的代价变大了。  </p></blockquote><h4 id="Tagged-Pointer-格式变化"><a href="#Tagged-Pointer-格式变化" class="headerlink" title="Tagged Pointer 格式变化"></a>Tagged Pointer 格式变化</h4><p>优化前的 Tagged Pointer 会将标识位（是否为 Tagged Pointer）存在指针地址的最低位，之后的三位用来标识<strong>数据类型</strong>，包含 7 种情况。其中的<code>OBJC_TAG_7</code>类型还会将接下来的后 8 位用于记录拓展类型，以支持如<code>UIColor</code>之类的对象。</p><p>本次优化在 ARM 中将上述标识位的位置做了调整，将最高位作为 Tagged Pointer 的标识位，<strong>拓展类型</strong>位于之后的 8 位，而<strong>数据类型</strong>标识放在最低三位。</p><p>这样的调整会对<code>objc_msgSend</code>有一定优化，因为 msgSend 的会判断指针类型，包括普通指针、 Tagged Pointer 或 nil 。将标识位放在最高位可以一次判断出是否为后两者，而不用分别检查，节省了条件分支。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>记录一下 Rx 中的一个常用操作符<code>flatMap</code>。</p><p>该操作符的意思是将源<code>Observable</code>的元素应用一个转换方法，将其转换为<code>Observables</code>，然后将这些<code>Observables</code>的元素合并（flat）之后发送出来。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.74.md" target="_blank" rel="noopener">带你打造一套 APM 监控系统</a></p><p>本篇文章比较全面的介绍了 iOS 端重要的几个性能监控的指标及其原理和方案，是一篇不错的总结。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第六周</title>
    <link href="http://yoursite.com/2020/07/12/ARTS_week_6/"/>
    <id>http://yoursite.com/2020/07/12/ARTS_week_6/</id>
    <published>2020-07-11T16:00:00.000Z</published>
    <updated>2020-07-12T14:07:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">LeetCode 7：整数反转</a></p><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br>注意:<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为[−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br><span class="line"></span><br><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br><span class="line"></span><br><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可看作将一个栈中的数据依次弹出存入另一栈中，但需要考虑溢出的情况，即入栈后的数字若超过<code>Int32</code>的范围，应直接返回零。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(<span class="number">_</span> x: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> tx = x</span><br><span class="line">        <span class="keyword">var</span> pop = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tx != <span class="number">0</span> &#123;</span><br><span class="line">            pop = tx%<span class="number">10</span></span><br><span class="line">            tx/=<span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> res &gt; <span class="type">Int32</span>.<span class="built_in">max</span>/<span class="number">10</span> || (res == <span class="type">Int32</span>.<span class="built_in">max</span>/<span class="number">10</span> &amp;&amp; pop &gt; <span class="number">7</span>) &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="type">Int32</span>.<span class="built_in">min</span>/<span class="number">10</span> || (res == <span class="type">Int32</span>.<span class="built_in">min</span>/<span class="number">10</span> &amp;&amp; pop &lt; -<span class="number">8</span>) &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + pop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://sdtimes.com/nasas-10-rules-developing-safety-critical-code/" target="_blank" rel="noopener">NASA’s 10 rules for developing safety-critical code - SD Times</a></p><p>本文介绍了 <strong>NASA</strong> 经过数十年软件工作所积累下来的软件开发领域的编码准则，堪称经典。再看目前项目中累计多年下来的代码觉得有很多由于规范上的、标准上的缺失，导致可读性、可维护性和可拓展性较差。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>记录一下如何获取应用的<strong>内存阀值</strong>。iOS 使用 Jetsam 机制来控制系统的内存使用，当某个进程超过<strong>内存阀值</strong>就会被 Jetsam 强杀，当然从系统内存使用角度来看，你的 APP 可能并未到达阀值也会被杀，为了给其他活跃 APP 腾出空间。</p><p>使用 JetsamEvent 日志计算内存限制值，该日志会存于手机的<strong>设置-隐私-分析与改进-分析数据</strong>下，以 JetsamEvent 开头。日志中都是系统内核强杀 APP 留下的内存信息，使用顶部的<code>pageSize</code>字段和<code>rpages</code>字段，即<code>rpages * pageSize</code>即可得到 OOM 的阀值。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.74.md" target="_blank" rel="noopener">带你打造一套 APM 监控系统 之 OOM 问题</a></p><p>下周可能开始做数据上报组件的开发工作，最近也在了解相关的内容。看到这篇文章对 OOM 的机制和底层原理介绍的比较详细，与上周分享的那篇针对 OOM 的文章结合来看，可以对系统的内存分配机制、监控 OOM 、记录数据、内存优化等都会有一定的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第五周</title>
    <link href="http://yoursite.com/2020/07/05/ARTS_week_5/"/>
    <id>http://yoursite.com/2020/07/05/ARTS_week_5/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-07-05T14:21:36.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/submissions/" target="_blank" rel="noopener">LeetCode 225：用队列实现栈</a></p><blockquote><p>使用队列实现栈的下列操作：<br>push(x) – 元素 x 入栈<br>pop() – 移除栈顶元素<br>top() – 获取栈顶元素<br>empty() – 返回栈是否为空  </p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>本题主要考察<strong>栈</strong>这个数据结构的特性，比较简单。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> queue: [<span class="type">Int</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>() &#123;</span><br><span class="line">        queue = [<span class="type">Int</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> x: Int)</span></span> &#123;</span><br><span class="line">        queue.append(x)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !queue.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.popLast() ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">top</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> !queue.isEmpty <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.last ?? <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">empty</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="http://rx-marin.com/post/bind-multiple-cells/" target="_blank" rel="noopener">Binding to a table view with multiple cells and sections</a></p><p>本篇文章介绍了两种使用<code>RxSwift</code>将<code>tableView</code>与多种类型的 cell 和 section 绑定的方式。一种是用<code>RxCocoa</code>的<code>bind(to:)</code>，好处是不需添加额外依赖且逻辑简单，但无法绑定 section，另一种是使用<code>RxDataSources</code>，可适用多重 cell 和 section 的场景，也是笔者比较推荐的方式。</p><p>本文以简单例子介绍了如何将数据流绑定到<code>tableView</code>上，算是一篇比较好的上手材料。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>记录一个手势处理的问题，场景是一个自定义弹层添加了<code>UISwipeGestureRecognizer</code>的手势，目的是在用户左滑 pop 的时候可以拦截该手势并将弹层 dismiss，否则会出现 controller 被 pop 后弹层仍在显示的问题。</p><p>但实际发现并不能有效拦截该手势，猜测是系统的 gesture distance 更小，故处理方式为添加一个代理方法以达到手势<strong>并行</strong>处理的效果：<br><code>gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</code></p><p>这样自行注册的<code>UISwipeGestureRecognizer</code>便可同时相应事件了。</p><p>同时，当遇到手势冲突需要<strong>取舍</strong>时，可以试试以下两个代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 返回 true 时，gestureRecognizer 会失效</span><br><span class="line">func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldRequireFailureOf otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</span><br><span class="line"></span><br><span class="line">// 返回 true 时，otherGestureRecognizer 会失效</span><br><span class="line">func gestureRecognizer(_ gestureRecognizer: UIGestureRecognizer, shouldBeRequiredToFailBy otherGestureRecognizer: UIGestureRecognizer) -&gt; Bool</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://wetest.qq.com/lab/view/367.html" target="_blank" rel="noopener">iOS微信内存监控</a></p><p>本篇文章出自微信测试团队，背景是当时微信的日志无法正确反映 FOOM (Foreground Out Of Memory)的具体原因，从而开发的一款内存监控工具，介绍了实现原理、误判降低以及最后成果。</p><p>过程中有许多亮点值得学习，比如对 libmalloc 接口的使用、为了降低数据大小而对数据结构的选择以及如何减少误判的思路等等。</p><p>目前公司也准备开发一个数据上报组件，因此分享这篇文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第四周</title>
    <link href="http://yoursite.com/2020/06/27/ARTS_week_4/"/>
    <id>http://yoursite.com/2020/06/27/ARTS_week_4/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2020-06-28T13:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">LeetCode 21: 合并两个有序链表</a></p><blockquote><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>最近周围好几个同学在面试某厂时都碰到这道题，虽然简单但要在规定时间内跑通还是对细节有点要求的。思路比较简单就直接写解答吧。</p><h4 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">mergeTwoLists</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>)), *<span class="title">p</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p-&gt;next = (l1 == <span class="literal">NULL</span>) ? l2 : l1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://docs.microsoft.com/en-us/previous-versions/msp-n-p/hh848246%28v=pandp.10%29?redirectedfrom=MSDN" target="_blank" rel="noopener">The MVVM Pattern</a></p><p>本文出自微软，介绍了使用 <strong>MVVM</strong> 设计模式的动机，<strong>MVVM</strong> 是什么及其优势有哪些。</p><p><strong>MVVM</strong> 提供<strong>分离</strong>的概念，将应用的逻辑与视图清晰的分开有助于测试和维护，并使代码更易复用。数据的绑定为 <strong>View</strong> 和 <strong>ViewModel</strong>之间提供了联系。同时它让<strong>开发设计工作流</strong>和<strong>测试</strong>更加容易。</p><p><strong>MVVM</strong> 的三个核心组成分别为：<code>model</code>、<code>view</code>、<code>viewModel</code> ，文中将三者的作用及相互间的交互模式介绍的比较清晰。其中<code>viewModel</code>可视作<code>view</code>与<code>model</code>的中间人。</p><p>最后文中罗列了使用 <strong>MVVM</strong> 的优势有哪些，虽然 Windows Phone 已离我们远去，但毕竟 <strong>MVVM</strong> 是在微软诞生的，本文还是值得一看。</p><p>另外，与 <strong>iOS</strong> 中由 <strong>MVC</strong> 演化而来的 <strong>MVVM</strong> 还是有些区别的。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周主要在处理业务代码，未能总结到 Tip ，惭愧惭愧。</p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming/" target="_blank" rel="noopener">5 Things to Know About Reactive Programming</a></p><p>本文从五个方面介绍了理解<strong>响应式编程</strong>的要点，并用最流行的相应式框架 <strong>Rx</strong> 进行举例说明。</p><p><strong>响应式编程</strong>的核心是处理异步的数据流，数据流可分为“冷”和“热”两种，理解两者的区别十分重要。另外对异步的理解和代码的简洁和可读性的重视也是应该考虑的。最后文章梳理了<strong>响应式编程</strong>和<strong>响应式系统</strong>的区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第三周</title>
    <link href="http://yoursite.com/2020/06/21/ARTS_week_3/"/>
    <id>http://yoursite.com/2020/06/21/ARTS_week_3/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-21T14:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 287: 寻找重复数</a></p><blockquote><p>给定一个包含<code>n + 1</code>个整数的数组<code>nums</code>，其数字都在 1 到 n之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>示例 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>该算法可用<strong>二分法</strong>、<strong>二进制</strong>或<strong>快慢指针</strong>等等方法来解，本次主要记录一下<strong>快慢指针</strong>的方法。<br><strong>快慢指针</strong>的方法主要借鉴了 <strong>Floyd 判圈算法</strong>，该算法主要用于检测链表是否有环。在本题中对<code>nums</code>建图，可将问题等价为： <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode142:  环形链表 II</a>  ，可分别设置快慢指针，慢指针每次走一步，快指针每次走两步，根据 <strong>Floyd 判圈算法</strong>两指针在有环的情况下一定会相遇，相遇后将慢指针放置起点，然后两个指针每次同时走一步，相遇点便是答案。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> slow = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow)</span><br><span class="line"></span><br><span class="line">    slow = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://allegro.tech/2014/12/swift-method-dispatching.html" target="_blank" rel="noopener">Swift Method Dispatching</a></p><p><strong>Swift</strong> 作为一门静态语言，其在方法派发上的性能表现要强于 <strong>OC</strong> 不少，本文中主要介绍了 <strong>Swift</strong> 的方法派发机制。</p><p>在 <strong>OC</strong> 中，<strong>clang</strong> 会将方法调用翻译成对<code>objc_msgSend</code>这个函数的调用，传入相应的<code>target</code>、<code>SEl</code>以及参数，该方法是由汇编实现的，负责<strong>OC</strong>中的方法派发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id obj, SEL op, … )</span><br><span class="line">&#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line">    IMP imp = CacheLookup(c, op);</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        imp = class_getMethodImplementation(c, op);</span><br><span class="line">    &#125;</span><br><span class="line">    jump imp(obj, op, …);]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，影响效率的最大因素在于找到具体的方法实现<code>IMP</code>，如果方法缓存命中，那么效率上基本等同于在<code>hashMap</code>中取值，这种情况还好，但如果未命中，则需要去沿着继承体系在类的方法列表中寻找对应的实现并加入缓存，再跳到该实现执行具体函数，这样的派发方式相对较慢。因此<code>objc_msgSend</code>也被称为跳板函数。</p><p>在 <strong>Swift</strong> 中，使用了 <strong>Virtual Method Table</strong> 来支持运行时的方法绑定，文章通过对 <strong>SIL</strong> 的分析发现 <strong>vtable</strong> 本质上是一个 key 为方法名，value 为方法实现的字典，而通过汇编代码可以看到 <strong>Swift</strong> 代码几乎做到了将调用方法直接映射到处理器指令，并将调用对象存入寄存器中。通过传入对象中指向 <code>metadata</code> 的指针找到保存其类信息的结构体，进而通过偏移量找到相应的方法。</p><p>当打开编译期优化选项后，<strong>Swift</strong> 代码执行速度可能更快，原因在于：</p><ul><li>当编译器知道目标对象的具体类型后，non-final 方法可被直接调用</li><li>编译期会用内联的方式直接将方法实现内联至方法调用的地方，从而省去了函数调用的开销</li></ul><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周依旧记录 <strong>Swift</strong> 的新特性，版本来到<code>5.3</code>。</p><h4 id="Multi-pattern-catch-clauses"><a href="#Multi-pattern-catch-clauses" class="headerlink" title="Multi-pattern catch clauses"></a>Multi-pattern catch clauses</h4><p>简单来说，一个<code>catch</code>代码块可以 handle 多种错误类型了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureError: Error &#123;</span><br><span class="line">    case tooCold, tooHot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let result = try checkReactorOperational()</span><br><span class="line">    print(“Result: \(result)”)</span><br><span class="line">&#125; catch TemperatureError.tooHot, TemperatureError.tooCold &#123;</span><br><span class="line">    print(“Shut down the reactor!”)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(“An unknown error occurred.”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Multiple-trailing-closures"><a href="#Multiple-trailing-closures" class="headerlink" title="Multiple trailing closures"></a>Multiple trailing closures</h4><p>多个尾随闭包也被支持了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Before</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Synthesized-Comparable-conformance-for-enums"><a href="#Synthesized-Comparable-conformance-for-enums" class="headerlink" title="Synthesized Comparable conformance for enums"></a>Synthesized Comparable conformance for enums</h4><p>实现<code>Comparable</code>的枚举可以用来比大小了，如果带有的关联值也是<code>Comparable</code>的话，也是可以比的哦~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum WorldCupResult: Comparable &#123;</span><br><span class="line">    case neverWon</span><br><span class="line">    case winner(stars: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let americanMen = WorldCupResult.neverWon</span><br><span class="line">let americanWomen = WorldCupResult.winner(stars: 4)</span><br><span class="line">let japaneseMen = WorldCupResult.neverWon</span><br><span class="line">let japaneseWomen = WorldCupResult.winner(stars: 1)</span><br><span class="line"></span><br><span class="line">let teams = [americanMen, americanWomen, japaneseMen, japaneseWomen]</span><br><span class="line">let sortedByWins = teams.sorted()</span><br><span class="line">print(sortedByWins) // americanMen japaneseMen japaneseWomen americanWomen</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://mp.weixin.qq.com/s/nh5qifdneF_Y3xOJBy_ipg" target="_blank" rel="noopener">左耳朵耗子：什么是函数式编程？</a></p><p>因为新公司的项目使用一些 <strong>RxSwift</strong>，而自己本身对这块只是一知半解，希望今后能利用一些时间来把<strong>函数式响应式编程</strong>以及 <strong>MVVM</strong> 做一个系统的学习和实践，就以这篇耗子叔的<strong>函数式编程</strong>作为开始吧。</p><p>本文就<strong>函数式编程</strong>做了详细的介绍并配以生动的代码示例，从其历史到特点和应用的技术，还介绍了纯函数式语言 <strong>Scheme</strong>，最后通过对比的方式讲明了何为函数式编程思维方式。读了三遍，每次都有新的感受，让人迫不及待想去动手实践。😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第二周</title>
    <link href="http://yoursite.com/2020/06/13/ARTS_week_2/"/>
    <id>http://yoursite.com/2020/06/13/ARTS_week_2/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-14T14:01:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode 63: 不同路径</a></p><blockquote><p>一个机器人位于一个 <em>m x n</em>网格的左上角 。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="ARTS_week_2/robot_maze.png" alt><br> 网格中的障碍物和空位置分别用 1 和 0 来表示。<br><strong>说明：*</strong>m<em> 和 </em>n*的值均不超过 100。<br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>问题，从这类问题的解法考虑，首先应寻找<strong>最优子结构</strong>，然后写出<strong>状态转义方程</strong>并将其翻译为代码。<br>在本题中，<strong>最优子结构</strong>应是每个格子的不同可达路径数，<strong>边界条件</strong>为第一行和第一列中每个格子的可达路径数，因为其中的每个格子都可根据左一个或上一个格子直接得出，而最关键的<strong>状态转义方程</strong>应为：<code>格子的路径数 = 上一个格子的路径数 + 左一个格子的路径数</code><br>注：矩阵默认保存的数据为 0 或 1 即表示是否有障碍，但经算法遍历填充后为每个格子的不同路径数</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="number">_</span> obstacleGrid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> grid = obstacleGrid</span><br><span class="line">        <span class="keyword">let</span> column = obstacleGrid.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> row = obstacleGrid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = (grid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = (grid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">                <span class="keyword">if</span> grid[<span class="built_in">c</span>][r] == <span class="number">0</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = grid[<span class="built_in">c</span>-<span class="number">1</span>][r] + grid[<span class="built_in">c</span>][r-<span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[column-<span class="number">1</span>][row-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.callstats.io/blog/2018/05/16/explaining-webrtc-secure-real-time-transport-protocol-srtp" target="_blank" rel="noopener">Explaining the WebRTC Secure Real-Time Transport Protocol (SRTP)</a></p><p>本周在准备分享有关 WebRTC 的内容，之前对于 WebRTC 的协议栈并没有做过深入了解，正好趁此机会做一次补充。</p><p>本篇文章从 <strong>SRTP</strong> 协议入手，介绍了 <strong>RTP</strong> 协议栈的组成，以及 WebRTC 所使用的加密协议等。</p><p><strong>SRTP (Secure Real-Time Transport Protocol)</strong> 协议是对 <a href="https://tools.ietf.org/html/rfc3550" target="_blank" rel="noopener">RTP</a> 协议的拓展并提供了一系列的加密机制，以提升 RTP 协议的安全性。包括对 <strong>RTC</strong> 包的加密、数据源认证、密钥管理等。</p><p><strong>SRTP</strong> 使用 AES （一种被广泛应用的对称加密算法）作为数据加密算法，包含两种加密模式：Segmented Integer Counter Mode 和 f8-mode。</p><p>对于消息完整性的保证，<strong>SRTP</strong> 使用算法为数据包和部分包头创建认证标识（authentication tag），并将其添加到 <strong>RTC</strong> 包上。该标识用于数据包内容的验证以防止数据伪造。同时，认证还通过为每个数据包提供可序列可比较的下标以防止回复攻击。在 WebRTC 中，<strong>SRTP</strong> 为保证消息完整性使用了 HMAC-SHA1 算法。</p><p>为保障每个 session 的安全性，<strong>SRTP</strong> 使用密钥派生函数，基于 master key 生成一些派生 keys ，对每个独立 session 使用唯一的 key 以保证 session 的安全。</p><p>WebRTC 通过 <strong>SRTP-DTLS</strong> 协议以保证流的安全性，其中，<strong>SRTP</strong> 用于媒体流的加密，<strong>DTLS</strong> 用于用于数据流的加密。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周记录一下 <strong>Swift</strong> 5.2 在语言特性上的更新，本次的两个更新都与函数相关，函数在 <strong>Swift</strong> 中的地位和作用是非常重要的</p><p><strong>函数式的类型调用</strong><br>无论在类、结构体还是协议中，如果想以函数式的调用方式来调用对象，进而调用对象中的某个方法，可以通过在类型中声明方法：<code>callAsFunction()</code>来做到，以<code>class</code>为例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> color: <span class="type">UIColor</span> = .white</span><br><span class="line"><span class="keyword">var</span> mileAge: <span class="type">UInt</span> = <span class="number">0</span></span><br><span class="line">. . .</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callAsFunctions</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">info(band)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line"><span class="comment">// call as func</span></span><br><span class="line">car(“<span class="type">BMW</span>”)</span><br></pre></td></tr></table></figure></p><p><strong>使用 key paths 作为函数</strong><br>在 <strong>Swift</strong>5.2 中，可使用 <strong>key path</strong> 作为函数传参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let fruits: [Fruit] = . . .</span><br><span class="line"></span><br><span class="line">// before</span><br><span class="line">fruites.map&#123; $0.color &#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line">fruites.map(\.color)</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://draveness.me/whys-the-design-live-streaming-latency/" target="_blank" rel="noopener">为什么流媒体直播的延迟很高</a></p><p>在本周公司内部分享 <strong>WebRTC</strong> 时被同事问到 <strong>WebRTC</strong> 与 <strong>HLS</strong> 的区别，我的理解是从底层的协议到框架的设计和目标应用场景均有不同，前者的目标是点对点的实时通讯，而后者被设计为流媒体传输协议。但 <strong>WebRTC</strong> 也可被应用到直播场景中，需要额外搭建服务通讯模型。两者在直播场景下的表现如何还需深入了解。</p><p>本文从流媒体直播的链路入手分析，分析数据编码、数据传输、缓存等方面可能造成延迟的原因。对了解流媒体直播的链路有一定的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第一周</title>
    <link href="http://yoursite.com/2020/06/06/ARTS_week_1/"/>
    <id>http://yoursite.com/2020/06/06/ARTS_week_1/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-14T14:09:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode 70: 爬楼梯</a></p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢?<br><strong>注意：</strong>给定 n 是一个正整数。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>的题目，<strong>动态规划</strong>的核心思想是利用过去的结果解决未来的问题。即将问题分解为相对简单的<strong>子问题</strong>，顺序求解并保存结果，为下一子问题的求解提供信息。类似数学中的<strong>递推法</strong>。<br>对于本题，当总台阶数为 1 时，到达楼顶的方法为 1 ，总台阶数为 2 时，到达楼顶的方法为 2 。这便是我们已有解的<strong>子问题</strong>，下一步就是如何通过已知的条件去解决目标问题。对于本题而言，总台阶数为 n 的问题的解等于总台阶数为<code>n - 1</code>与<code>n - 2</code>的解的<strong>和</strong>，因为前两个台阶到达目标台阶的方式唯一且互斥（走 1 步或 2 步）。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> n &#125; <span class="comment">// n = 1, n = 2</span></span><br><span class="line"><span class="keyword">var</span> solutions = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">3</span> … n &#123;</span><br><span class="line">solutions.append(solutions[index-<span class="number">1</span>] + solutions[index-<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> solutions[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>时间复杂度：<strong>O(n)</strong>，空间复杂度：<strong>O(n)</strong></li></ul><hr><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" target="_blank" rel="noopener">When to Use Swift Structs and Classes</a></p><p>本文是一篇老文章了，来自<a href="https://www.mikeash.com/" target="_blank" rel="noopener">Mike Ash</a> 。因为之前在面试中常被问到<code>class</code>与<code>struct</code>的区别。所以想分享一下这篇文章。<br>其实最大的区别就是语义上的区别了，也是本文着重想要表达、同时也是我们日常使用时最应注意的问题：</p><blockquote><p><code>struct</code>是值类型，<code>class</code>是引用类型</p></blockquote><p>语义上的区别背后是两者存储方式的不同，<code>struct</code>存储在<strong>栈</strong>上，<code>class</code>存储在<strong>堆</strong>上，而<code>class</code>的引用保存在<strong>栈</strong>上。</p><p>对于<strong>值类型</strong>，当你对数据进行赋值时，你得到的是该数据的拷贝。而对于<strong>引用类型</strong>，你得到的将是对该数据引用的拷贝。</p><p>文中还对<strong>值语义</strong>进行了探讨，虽然很多语言坚持“万物皆对象”，甚至数字都是<strong>引用类型</strong>的，但它们不免会使用<code>不可变类型</code>，对于这样的类型而言，<strong>值/引用</strong>的区别消失了，或者说区别仅仅在于性能表现上了。</p><p>如何选择<strong>值类型</strong>或<strong>引用类型</strong>的核心问题在当数据被赋值后你希望得到一份数据的拷贝还是一份引用的拷贝，这就需要在具体的场景中分析了。</p><p>对于<strong>嵌套类型</strong>，有以下四种情况：</p><ul><li><strong>引用类型</strong>中包含<strong>引用类型</strong><br>并无特殊表现，持有外部或内部的引用均可改变该引用指向的值，且都可感知数据变化</li><li><strong>值类型</strong>中包含<strong>值类型</strong><br>并无特殊表现，嵌套的<strong>值类型</strong>被赋值时均会拷贝其内容</li><li><strong>引用类型</strong>中包含<strong>值类型</strong><br>外部的<strong>引用</strong>被赋值时，内部的<strong>值</strong>会被拷贝</li><li><strong>值类型</strong>中包含<strong>引用类型</strong><br>这种情况会破坏<strong>值语义</strong>，当外部数据被赋值时，内部数据仅会拷贝其引用。</li></ul><hr><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周因为刚入职，主要在配置环境和熟悉文档😂。所以记录下 SSH key 的生成：</p><ol><li>在终端输入<code>ssh-keygen</code></li><li>确认默认路径<code>.ssh/id_rsa</code></li><li>输入密码，也可跳过</li><li>打开 ssh 公钥文件：<code>~/.ssh/id_rsa.pub</code>，复制其中内容</li><li>粘贴至相应平台如 github </li></ol><blockquote><p>SSH 为 Secure Shell（安全外壳协议） 的缩写，是一种加密的网络传输协议。该协议在网络创建<strong>安全隧道</strong>来实现 SSH 客户端与服务端的连接。<br>以<strong>非对称加密</strong>的方式身份验证。  </p></blockquote><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="http://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code" target="_blank" rel="noopener">如何阅读别人的代码</a>  </p><p>该篇文章出自垠神，因为上周刚刚接手项目，首要任务就是熟悉业务和代码。当然垠神跟我等菜鸡的关注点肯定是不同的，他的方式也不一定适用，因此算是借题发挥吧。  </p><p>首先要了解的是项目的整体框架和工程的组织结构，一般主工程会按照业务模块划分，当然也可能会包括一些工具类或三方的组件啥的。另外工程的配置、引入的<code>framework</code>或<code>library</code>也应该了解一下。有些项目还会混编 <code>Objective-c</code>和<code>Swift</code>。如果能用类图或思维导图将项目框架构建出来肯定是更好的。  </p><p>一般 iOS 工程会用第三方的库管理工具如 CocoaPods ，因此需要了解项目使用了哪些第三方库，在 iOS 中许多应用方向的三方库都具有“垄断”地位，如<code>AFNetworking</code>、<code>FMDB</code>、<code>Masonry</code>等等，因此了解这些三方库的使用及实现就非常重要，即使项目中对其进行二次封装也可以很快上手。  </p><p>接下来就是代码的熟悉了，有些公司会有代码规范的要求或接入了规范检查工具，因此最好先了解下具体要求。另外就要看看是否有编程范式的要求或使用了某些框架如<code>Rx</code>、<code>PromiseKit</code>啥的。  </p><p>当然只看不写效果不会太好，最好从模块业务或组件入手去实际开发，多和同事沟通，多请大伙给你 code review ，慢慢从点扩展到面，一定会很快上手的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
</feed>
