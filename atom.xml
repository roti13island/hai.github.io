<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hays‘</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-21T14:31:09.238Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hays Ren</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARTS 第三周</title>
    <link href="http://yoursite.com/2020/06/21/ARTS_week_3/"/>
    <id>http://yoursite.com/2020/06/21/ARTS_week_3/</id>
    <published>2020-06-20T16:00:00.000Z</published>
    <updated>2020-06-21T14:31:09.238Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">LeetCode 287: 寻找重复数</a></p><blockquote><p>给定一个包含<code>n + 1</code>个整数的数组<code>nums</code>，其数字都在 1 到 n之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。<br><strong>示例 :</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>该算法可用<strong>二分法</strong>、<strong>二进制</strong>或<strong>快慢指针</strong>等等方法来解，本次主要记录一下<strong>快慢指针</strong>的方法。<br><strong>快慢指针</strong>的方法主要借鉴了<strong>Floyd 判圈算法</strong>，该算法主要用于检测链表是否有环。在本题中对<code>nums</code>建图，可将问题等价为： <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/" target="_blank" rel="noopener">LeetCode142:  环形链表 II</a>  ，可分别设置快慢指针，慢指针每次走一步，快指针每次走两步，根据<strong>Floyd 判圈算法</strong>两指针在有环的情况下一定会相遇，相遇后将慢指针放置起点，然后两个指针每次同时走一步，相遇点便是答案。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDuplicate</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fast = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">var</span> slow = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">repeat</span> &#123;</span><br><span class="line">        fast = nums[nums[fast]]</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">    &#125; <span class="keyword">while</span> (fast != slow)</span><br><span class="line"></span><br><span class="line">    slow = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = nums[slow]</span><br><span class="line">        fast = nums[fast]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://allegro.tech/2014/12/swift-method-dispatching.html" target="_blank" rel="noopener">Swift Method Dispatching</a></p><p><strong>Swift</strong>作为一门静态语言，其在方法派发上的性能表现要强于<strong>OC</strong>不少，本文中主要介绍了<strong>Swift</strong>的方法派发机制。</p><p>在<strong>OC</strong>中，<strong>clang</strong>会将方法调用翻译成对<code>objc_msgSend</code>这个函数的调用，传入相应的<code>target</code>、<code>SEl</code>以及参数，该方法是由汇编实现的，负责<strong>OC</strong>中的方法派发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSend ( id obj, SEL op, … )</span><br><span class="line">&#123;</span><br><span class="line">    Class c = object_getClass(obj);</span><br><span class="line">    IMP imp = CacheLookup(c, op);</span><br><span class="line">    if (!imp) &#123;</span><br><span class="line">        imp = class_getMethodImplementation(c, op);</span><br><span class="line">    &#125;</span><br><span class="line">    jump imp(obj, op, …);]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，影响效率的最大因素在于找到具体的方法实现<code>IMP</code>，如果方法缓存命中，那么效率上基本等同于在<code>hashMap</code>中取值，这种情况还好，但如果未命中，则需要去沿着继承体系在类的方法列表中寻找对应的实现并加入缓存，再跳到该实现执行具体函数，这样的派发方式相对较慢。因此<code>objc_msgSend</code>也被称为跳板函数。</p><p>在<strong>Swift</strong>中，使用了<strong>Virtual Method Table</strong>来支持运行时的方法绑定，文章通过对<strong>SIL</strong>的分析发现<strong>vtable</strong>本质上是一个 key 为方法名，value 为方法实现的字典，而通过汇编代码可以看到<strong>Swift</strong>代码几乎做到了将调用方法直接映射到处理器指令，并将调用对象存入寄存器中。通过传入对象中指向<code>metadata</code>的指针找到保存其类信息的结构体，进而通过偏移量找到相应的方法。</p><p>当打开编译期优化选项后，<strong>Swift</strong>代码执行速度可能更快，原因在于：<br>当编译器知道目标对象的具体类型后，non-final 方法可被直接调用<br>编译期会用内联的方式直接将方法实现内联至方法调用的地方，从而省去了函数调用的开销</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周依旧记录<strong>Swift</strong>的新特性，版本来到<code>5.3</code>。</p><p><strong>Multi-pattern catch clauses</strong><br>简单来说，一个<code>catch</code>代码块可以 handle 多种错误类型了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum TemperatureError: Error &#123;</span><br><span class="line">    case tooCold, tooHot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">    let result = try checkReactorOperational()</span><br><span class="line">    print(“Result: \(result)”)</span><br><span class="line">&#125; catch TemperatureError.tooHot, TemperatureError.tooCold &#123;</span><br><span class="line">    print(“Shut down the reactor!”)</span><br><span class="line">&#125; catch &#123;</span><br><span class="line">    print(“An unknown error occurred.”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Multiple trailing closures</strong><br>多个尾随闭包也被支持了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// Before</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// After</span><br><span class="line">struct NewContentView: View &#123;</span><br><span class="line">    @State private var showOptions = false</span><br><span class="line"></span><br><span class="line">    var body: some View &#123;</span><br><span class="line">        Button &#123;</span><br><span class="line">            self.showOptions.toggle()</span><br><span class="line">        &#125; label: &#123;</span><br><span class="line">            Image(systemName: &quot;gear&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>Synthesized Comparable conformance for enums</strong><br>实现<code>Comparable</code>的枚举可以用来比大小了，如果带有的关联值也是<code>Comparable</code>的话，也是可以比的哦~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">enum WorldCupResult: Comparable &#123;</span><br><span class="line">    case neverWon</span><br><span class="line">    case winner(stars: Int)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let americanMen = WorldCupResult.neverWon</span><br><span class="line">let americanWomen = WorldCupResult.winner(stars: 4)</span><br><span class="line">let japaneseMen = WorldCupResult.neverWon</span><br><span class="line">let japaneseWomen = WorldCupResult.winner(stars: 1)</span><br><span class="line"></span><br><span class="line">let teams = [americanMen, americanWomen, japaneseMen, japaneseWomen]</span><br><span class="line">let sortedByWins = teams.sorted()</span><br><span class="line">print(sortedByWins) // americanMen japaneseMen japaneseWomen americanWomen</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://mp.weixin.qq.com/s/nh5qifdneF_Y3xOJBy_ipg" target="_blank" rel="noopener">左耳朵耗子：什么是函数式编程？</a></p><p>因为新公司的项目使用一些<strong>RxSwift</strong>，而自己本身对这块只是一知半解，希望今后能利用一些时间来把<strong>函数式响应式编程</strong>以及<strong>MVVM</strong>做一个系统的学习和实践，就以这篇耗子叔的<strong>函数式编程</strong>作为开始吧。</p><p>本文就<strong>函数式编程</strong>做了详细的介绍并配以生动的代码示例，从其历史到特点和应用的技术，还介绍了纯函数式语言<strong>Scheme</strong>，最后通过对比的方式讲明了何为函数式编程思维方式。读了三遍，每次都有新的感受，让人迫不及待想去动手实践。😜</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第二周</title>
    <link href="http://yoursite.com/2020/06/13/ARTS_week_2/"/>
    <id>http://yoursite.com/2020/06/13/ARTS_week_2/</id>
    <published>2020-06-12T16:00:00.000Z</published>
    <updated>2020-06-14T14:01:23.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/unique-paths-ii/" target="_blank" rel="noopener">LeetCode 63: 不同路径</a></p><blockquote><p>一个机器人位于一个 <em>m x n</em>网格的左上角 。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br><img src="ARTS_week_2/robot_maze.png" alt><br> 网格中的障碍物和空位置分别用 1 和 0 来表示。<br><strong>说明：*</strong>m<em> 和 </em>n*的值均不超过 100。<br><strong>示例 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [0,1,0],</span><br><span class="line">  [0,0,0]</span><br><span class="line">]</span><br><span class="line">输出: 2</span><br><span class="line">解释:</span><br><span class="line">3x3 网格的正中间有一个障碍物。</span><br><span class="line">从左上角到右下角一共有 2 条不同的路径：</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>问题，从这类问题的解法考虑，首先应寻找<strong>最优子结构</strong>，然后写出<strong>状态转义方程</strong>并将其翻译为代码。<br>在本题中，<strong>最优子结构</strong>应是每个格子的不同可达路径数，<strong>边界条件</strong>为第一行和第一列中每个格子的可达路径数，因为其中的每个格子都可根据左一个或上一个格子直接得出，而最关键的<strong>状态转义方程</strong>应为：<code>格子的路径数 = 上一个格子的路径数 + 左一个格子的路径数</code><br>注：矩阵默认保存的数据为 0 或 1 即表示是否有障碍，但经算法遍历填充后为每个格子的不同路径数</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="number">_</span> obstacleGrid: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> grid = obstacleGrid</span><br><span class="line">        <span class="keyword">let</span> column = obstacleGrid.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> row = obstacleGrid[<span class="number">0</span>].<span class="built_in">count</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            grid[i][<span class="number">0</span>] = (grid[i][<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; grid[i-<span class="number">1</span>][<span class="number">0</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">            grid[<span class="number">0</span>][i] = (grid[<span class="number">0</span>][i] == <span class="number">0</span> &amp;&amp; grid[<span class="number">0</span>][i-<span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">c</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;column &#123;</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> <span class="number">1</span>..&lt;row &#123;</span><br><span class="line">                <span class="keyword">if</span> grid[<span class="built_in">c</span>][r] == <span class="number">0</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = grid[<span class="built_in">c</span>-<span class="number">1</span>][r] + grid[<span class="built_in">c</span>][r-<span class="number">1</span>]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    grid[<span class="built_in">c</span>][r] = <span class="number">0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grid[column-<span class="number">1</span>][row-<span class="number">1</span>]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.callstats.io/blog/2018/05/16/explaining-webrtc-secure-real-time-transport-protocol-srtp" target="_blank" rel="noopener">Explaining the WebRTC Secure Real-Time Transport Protocol (SRTP)</a></p><p>本周在准备分享有关 WebRTC 的内容，之前对于 WebRTC 的协议栈并没有做过深入了解，正好趁此机会做一次补充。</p><p>本篇文章从 <strong>SRTP</strong> 协议入手，介绍了 <strong>RTP</strong> 协议栈的组成，以及 WebRTC 所使用的加密协议等。</p><p><strong>SRTP (Secure Real-Time Transport Protocol)</strong> 协议是对 <a href="https://tools.ietf.org/html/rfc3550" target="_blank" rel="noopener">RTP</a> 协议的拓展并提供了一系列的加密机制，以提升 RTP 协议的安全性。包括对 <strong>RTC</strong> 包的加密、数据源认证、密钥管理等。</p><p><strong>SRTP</strong> 使用 AES （一种被广泛应用的对称加密算法）作为数据加密算法，包含两种加密模式：Segmented Integer Counter Mode 和 f8-mode。</p><p>对于消息完整性的保证，<strong>SRTP</strong> 使用算法为数据包和部分包头创建认证标识（authentication tag），并将其添加到 <strong>RTC</strong> 包上。该标识用于数据包内容的验证以防止数据伪造。同时，认证还通过为每个数据包提供可序列可比较的下标以防止回复攻击。在 WebRTC 中，<strong>SRTP</strong> 为保证消息完整性使用了 HMAC-SHA1 算法。</p><p>为保障每个 session 的安全性，<strong>SRTP</strong> 使用密钥派生函数，基于 master key 生成一些派生 keys ，对每个独立 session 使用唯一的 key 以保证 session 的安全。</p><p>WebRTC 通过 <strong>SRTP-DTLS</strong> 协议以保证流的安全性，其中，<strong>SRTP</strong> 用于媒体流的加密，<strong>DTLS</strong> 用于用于数据流的加密。</p><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周记录一下 <strong>Swift</strong> 5.2 在语言特性上的更新，本次的两个更新都与函数相关，函数在 <strong>Swift</strong> 中的地位和作用是非常重要的</p><p><strong>函数式的类型调用</strong><br>无论在类、结构体还是协议中，如果想以函数式的调用方式来调用对象，进而调用对象中的某个方法，可以通过在类型中声明方法：<code>callAsFunction()</code>来做到，以<code>class</code>为例：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="keyword">var</span> color: <span class="type">UIColor</span> = .white</span><br><span class="line"><span class="keyword">var</span> mileAge: <span class="type">UInt</span> = <span class="number">0</span></span><br><span class="line">. . .</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">info</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">. . .</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callAsFunctions</span><span class="params">(<span class="number">_</span> band: String)</span></span> &#123;</span><br><span class="line">info(band)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = <span class="type">Car</span>()</span><br><span class="line"><span class="comment">// call as func</span></span><br><span class="line">car(“<span class="type">BMW</span>”)</span><br></pre></td></tr></table></figure></p><p><strong>使用 key paths 作为函数</strong><br>在 <strong>Swift</strong>5.2 中，可使用 <strong>key path</strong> 作为函数传参：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let fruits: [Fruit] = . . .</span><br><span class="line"></span><br><span class="line">// before</span><br><span class="line">fruites.map&#123; $0.color &#125;</span><br><span class="line"></span><br><span class="line">// after</span><br><span class="line">fruites.map(\.color)</span><br></pre></td></tr></table></figure></p><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="https://draveness.me/whys-the-design-live-streaming-latency/" target="_blank" rel="noopener">为什么流媒体直播的延迟很高</a></p><p>在本周公司内部分享 <strong>WebRTC</strong> 时被同事问到 <strong>WebRTC</strong> 与 <strong>HLS</strong> 的区别，我的理解是从底层的协议到框架的设计和目标应用场景均有不同，前者的目标是点对点的实时通讯，而后者被设计为流媒体传输协议。但 <strong>WebRTC</strong> 也可被应用到直播场景中，需要额外搭建服务通讯模型。两者在直播场景下的表现如何还需深入了解。</p><p>本文从流媒体直播的链路入手分析，分析数据编码、数据传输、缓存等方面可能造成延迟的原因。对了解流媒体直播的链路有一定的帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
  <entry>
    <title>ARTS 第一周</title>
    <link href="http://yoursite.com/2020/06/06/ARTS_week_1/"/>
    <id>http://yoursite.com/2020/06/06/ARTS_week_1/</id>
    <published>2020-06-05T16:00:00.000Z</published>
    <updated>2020-06-14T14:09:38.605Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><p><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">LeetCode 70: 爬楼梯</a></p><blockquote><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢?<br><strong>注意：</strong>给定 n 是一个正整数。<br><strong>示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></p></blockquote><p><strong>思路：</strong><br>本题是一道<strong>动态规划</strong>的题目，<strong>动态规划</strong>的核心思想是利用过去的结果解决未来的问题。即将问题分解为相对简单的<strong>子问题</strong>，顺序求解并保存结果，为下一子问题的求解提供信息。类似数学中的<strong>递推法</strong>。<br>对于本题，当总台阶数为 1 时，到达楼顶的方法为 1 ，总台阶数为 2 时，到达楼顶的方法为 2 。这便是我们已有解的<strong>子问题</strong>，下一步就是如何通过已知的条件去解决目标问题。对于本题而言，总台阶数为 n 的问题的解等于总台阶数为<code>n - 1</code>与<code>n - 2</code>的解的<strong>和</strong>，因为前两个台阶到达目标台阶的方式唯一且互斥（走 1 步或 2 步）。</p><p><strong>解答：</strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line"><span class="keyword">guard</span> n &gt; <span class="number">2</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> n &#125; <span class="comment">// n = 1, n = 2</span></span><br><span class="line"><span class="keyword">var</span> solutions = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">3</span> … n &#123;</span><br><span class="line">solutions.append(solutions[index-<span class="number">1</span>] + solutions[index-<span class="number">2</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> solutions[n]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>时间复杂度：<strong>O(n)</strong>，空间复杂度：<strong>O(n)</strong></li></ul><hr><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-07-17-when-to-use-swift-structs-and-classes.html" target="_blank" rel="noopener">When to Use Swift Structs and Classes</a></p><p>本文是一篇老文章了，来自<a href="https://www.mikeash.com/" target="_blank" rel="noopener">Mike Ash</a> 。因为之前在面试中常被问到<code>class</code>与<code>struct</code>的区别。所以想分享一下这篇文章。<br>其实最大的区别就是语义上的区别了，也是本文着重想要表达、同时也是我们日常使用时最应注意的问题：</p><blockquote><p><code>struct</code>是值类型，<code>class</code>是引用类型</p></blockquote><p>语义上的区别背后是两者存储方式的不同，<code>struct</code>存储在<strong>栈</strong>上，<code>class</code>存储在<strong>堆</strong>上，而<code>class</code>的引用保存在<strong>栈</strong>上。</p><p>对于<strong>值类型</strong>，当你对数据进行赋值时，你得到的是该数据的拷贝。而对于<strong>引用类型</strong>，你得到的将是对该数据引用的拷贝。</p><p>文中还对<strong>值语义</strong>进行了探讨，虽然很多语言坚持“万物皆对象”，甚至数字都是<strong>引用类型</strong>的，但它们不免会使用<code>不可变类型</code>，对于这样的类型而言，<strong>值/引用</strong>的区别消失了，或者说区别仅仅在于性能表现上了。</p><p>如何选择<strong>值类型</strong>或<strong>引用类型</strong>的核心问题在当数据被赋值后你希望得到一份数据的拷贝还是一份引用的拷贝，这就需要在具体的场景中分析了。</p><p>对于<strong>嵌套类型</strong>，有以下四种情况：</p><ul><li><strong>引用类型</strong>中包含<strong>引用类型</strong><br>并无特殊表现，持有外部或内部的引用均可改变该引用指向的值，且都可感知数据变化</li><li><strong>值类型</strong>中包含<strong>值类型</strong><br>并无特殊表现，嵌套的<strong>值类型</strong>被赋值时均会拷贝其内容</li><li><strong>引用类型</strong>中包含<strong>值类型</strong><br>外部的<strong>引用</strong>被赋值时，内部的<strong>值</strong>会被拷贝</li><li><strong>值类型</strong>中包含<strong>引用类型</strong><br>这种情况会破坏<strong>值语义</strong>，当外部数据被赋值时，内部数据仅会拷贝其引用。</li></ul><hr><h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><p>本周因为刚入职，主要在配置环境和熟悉文档😂。所以记录下 SSH key 的生成：</p><ol><li>在终端输入<code>ssh-keygen</code></li><li>确认默认路径<code>.ssh/id_rsa</code></li><li>输入密码，也可跳过</li><li>打开 ssh 公钥文件：<code>~/.ssh/id_rsa.pub</code>，复制其中内容</li><li>粘贴至相应平台如 github </li></ol><blockquote><p>SSH 为 Secure Shell（安全外壳协议） 的缩写，是一种加密的网络传输协议。该协议在网络创建<strong>安全隧道</strong>来实现 SSH 客户端与服务端的连接。<br>以<strong>非对称加密</strong>的方式身份验证。  </p></blockquote><hr><h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p><a href="http://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code" target="_blank" rel="noopener">如何阅读别人的代码</a>  </p><p>该篇文章出自垠神，因为上周刚刚接手项目，首要任务就是熟悉业务和代码。当然垠神跟我等菜鸡的关注点肯定是不同的，他的方式也不一定适用，因此算是借题发挥吧。  </p><p>首先要了解的是项目的整体框架和工程的组织结构，一般主工程会按照业务模块划分，当然也可能会包括一些工具类或三方的组件啥的。另外工程的配置、引入的<code>framework</code>或<code>library</code>也应该了解一下。有些项目还会混编 <code>Objective-c</code>和<code>Swift</code>。如果能用类图或思维导图将项目框架构建出来肯定是更好的。  </p><p>一般 iOS 工程会用第三方的库管理工具如 CocoaPods ，因此需要了解项目使用了哪些第三方库，在 iOS 中许多应用方向的三方库都具有“垄断”地位，如<code>AFNetworking</code>、<code>FMDB</code>、<code>Masonry</code>等等，因此了解这些三方库的使用及实现就非常重要，即使项目中对其进行二次封装也可以很快上手。  </p><p>接下来就是代码的熟悉了，有些公司会有代码规范的要求或接入了规范检查工具，因此最好先了解下具体要求。另外就要看看是否有编程范式的要求或使用了某些框架如<code>Rx</code>、<code>PromiseKit</code>啥的。  </p><p>当然只看不写效果不会太好，最好从模块业务或组件入手去实际开发，多和同事沟通，多请大伙给你 code review ，慢慢从点扩展到面，一定会很快上手的。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Algorithm&quot;&gt;&lt;a href=&quot;#Algorithm&quot; class=&quot;headerlink&quot; title=&quot;Algorithm&quot;&gt;&lt;/a&gt;Algorithm&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/
      
    
    </summary>
    
      <category term="ARTS" scheme="http://yoursite.com/categories/ARTS/"/>
    
    
  </entry>
  
</feed>
